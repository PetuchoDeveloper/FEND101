<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Semana 3: ProgramaciÃ³n AsÃ­ncrona y Concurrencia en el Cliente | AETL</title>
    <link href="https://fonts.googleapis.com/css2?family=Source+Serif+4:opsz,wght@8..60,400;8..60,600;8..60,700&family=JetBrains+Mono:wght@400;500;600&family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="aetl-styles.css">
</head>
<body>
    <!-- ========== HEADER INSTITUCIONAL ========== -->
    <header class="header-institucional">
        <div class="header-top">
            <div class="uan-logo">
                <div class="uan-logo-icon">UAN</div>
                <div class="uan-logo-text">
                    <span>Universidad AutÃ³noma de Nayarit</span>
                    <span>Licenciatura en Sistemas Computacionales</span>
                </div>
            </div>
            <div class="header-badge">MODELO AETL</div>
        </div>
        <div class="header-main">
            <p class="header-curso">ProgramaciÃ³n Distribuida del Lado del Cliente</p>
            <h1 class="header-titulo">
                ProgramaciÃ³n <span class="accent">AsÃ­ncrona</span><br>
                y Concurrencia en el Cliente
            </h1>
            <div class="header-semana">
                <div class="header-semana-numero">3</div>
                <span>Semana 3 de 15 Â· Fase 1: Fundamentos de ComunicaciÃ³n</span>
            </div>
        </div>
    </header>

    <!-- ========== NAVEGACIÃ“N ========== -->
    <nav class="nav-container">
        <div class="nav-fases">
            <a href="#comprende" class="nav-fase" data-fase="comprende">
                <span class="nav-fase-numero">1</span>
                <span>Comprende</span>
            </a>
            <a href="#aplica" class="nav-fase" data-fase="aplica">
                <span class="nav-fase-numero">2</span>
                <span>Aplica</span>
            </a>
            <a href="#reflexiona" class="nav-fase" data-fase="reflexiona">
                <span class="nav-fase-numero">3</span>
                <span>Reflexiona</span>
            </a>
            <a href="#valida" class="nav-fase" data-fase="valida">
                <span class="nav-fase-numero">4</span>
                <span>Valida</span>
            </a>
            <a href="#profundiza" class="nav-fase" data-fase="profundiza">
                <span class="nav-fase-numero">5</span>
                <span>Profundiza</span>
            </a>
            <a href="#evaluacion" class="nav-fase">
                <span>ğŸ“Š</span>
                <span>EvaluaciÃ³n</span>
            </a>
            <a href="#glosario" class="nav-fase">
                <span>ğŸ“–</span>
                <span>Glosario</span>
            </a>
        </div>
    </nav>

    <!-- ========== BARRA DE PROGRESO ========== -->
    <div class="progress-container">
        <div class="progress-inner">
            <div class="progress-header">
                <span class="progress-title">ğŸ¯ Progreso del Aprendizaje Profundo</span>
                <span class="progress-stats">Fase actual: Comprende</span>
            </div>
            <div class="progress-bar">
                <div class="progress-segment" data-fase="comprende"></div>
                <div class="progress-segment" data-fase="aplica"></div>
                <div class="progress-segment" data-fase="reflexiona"></div>
                <div class="progress-segment" data-fase="valida"></div>
                <div class="progress-segment" data-fase="profundiza"></div>
            </div>
            <div class="progress-legend">
                <div class="progress-legend-item">
                    <div class="progress-legend-dot" style="background: var(--fase-comprende);"></div>
                    <span>Comprende</span>
                </div>
                <div class="progress-legend-item">
                    <div class="progress-legend-dot" style="background: var(--fase-aplica);"></div>
                    <span>Aplica</span>
                </div>
                <div class="progress-legend-item">
                    <div class="progress-legend-dot" style="background: var(--fase-reflexiona);"></div>
                    <span>Reflexiona</span>
                </div>
                <div class="progress-legend-item">
                    <div class="progress-legend-dot" style="background: var(--fase-valida);"></div>
                    <span>Valida</span>
                </div>
                <div class="progress-legend-item">
                    <div class="progress-legend-dot" style="background: var(--fase-profundiza);"></div>
                    <span>Profundiza</span>
                </div>
            </div>
        </div>
    </div>

    <!-- ========== CONTENIDO PRINCIPAL ========== -->
    <main class="main-content">
        
        <!-- ========== ESCENARIO INMERSIVO ========== -->
        <section class="escenario-inmersivo">
            <div class="escenario-badge">
                <span>ğŸ¬</span>
                <span>ESCENARIO INMERSIVO</span>
            </div>
            <h2 class="escenario-titulo">TechNova DÃ­a 3: La Demo que se Congela</h2>
            <div class="escenario-contexto">
                <p>MiÃ©rcoles en <strong>TechNova</strong>. Tu cliente CRUD funciona perfectamenteâ€¦ cuando sÃ³lo haces una peticiÃ³n a la vez. Pero hoy, la Product Manager necesita la pantalla de dashboard: <em>"Cuando el usuario abre la app, necesitamos cargar simultÃ¡neamente el catÃ¡logo de productos, las categorÃ­as, el perfil del usuario y las notificaciones pendientes. Todo al mismo tiempo."</em></p>
                <p style="margin-top: 1rem;">Haces la prueba con tu cliente sÃ­ncrono. Cuatro peticiones secuenciales. Cada una tarda ~500ms. Resultado: <strong>2 segundos de pantalla en blanco</strong> mientras el usuario espera. La Product Manager frunce el ceÃ±o: <em>"Google dice que si la carga tarda mÃ¡s de 1 segundo, perdemos el 30% de los usuarios. Â¿No puedes lanzar todas las peticiones al mismo tiempo?"</em></p>
                <p style="margin-top: 1rem;">Peor aÃºn: cuando una de las cuatro peticiones falla por timeout, las otras tres â€” que ya completaron â€” se pierden porque tu cÃ³digo sÃ­ncrono aborta todo el bloque. El equipo de backend pregunta: <em>"Â¿Por quÃ© tu cliente espera a que termine una peticiÃ³n para lanzar la siguiente? Nuestro servidor puede manejar todas en paralelo."</em></p>
            </div>
            <div class="escenario-rol">
                <div class="escenario-rol-icon">âš¡</div>
                <div class="escenario-rol-text">
                    <h4>Tu Rol: Arquitecto de Flujos Concurrentes</h4>
                    <p>Ya sabes consumir APIs y validar respuestas. Esta semana aprenderÃ¡s a lanzar <strong>mÃºltiples peticiones simultÃ¡neas</strong>, coordinar sus resultados, cancelar las que ya no necesitas, y manejar timeouts individuales sin perder trabajo Ãºtil.</p>
                </div>
            </div>
        </section>

        <!-- ========== PREREQUISITOS ========== -->
        <section class="prerequisitos-box">
            <h3>ğŸ”‘ Para tener Ã©xito esta semana, asegÃºrate de recordar...</h3>
            <ul class="prerequisitos-lista">
                <li>CÃ³mo funciona tu cliente CRUD sÃ­ncrono de la Semana 2 (funciones, validadores, manejo de errores)</li>
                <li>La diferencia entre errores 4xx (no reintentar) y 5xx (posiblemente reintentar)</li>
                <li>QuÃ© significa que una operaciÃ³n sea <strong>idempotente</strong> y por quÃ© importa para reintentos</li>
                <li>CÃ³mo funciona el event loop de Python (o del lenguaje elegido) a nivel conceptual</li>
                <li>El concepto de <strong>timeout</strong> y por quÃ© toda peticiÃ³n debe tener uno configurado</li>
            </ul>
        </section>

        <!-- ========== CONEXIÃ“N CON SEMANA ANTERIOR ========== -->
        <section class="conexion-semana-anterior">
            <h3>ğŸ”— ConexiÃ³n directa con Semana 2</h3>
            <ul class="conexion-lista">
                <li><strong>Cliente CRUD completo:</strong> Las funciones que escribiste (listar, obtener, crear, actualizar, eliminar) serÃ¡n la base. Esta semana las convertirÃ¡s de sÃ­ncronas a asÃ­ncronas sin perder la validaciÃ³n.</li>
                <li><strong>Manejo de errores diferenciado:</strong> Tu lÃ³gica de errores 4xx vs 5xx ahora debe funcionar por peticiÃ³n individual, no globalmente. Si una peticiÃ³n falla, las demÃ¡s deben continuar.</li>
                <li><strong>Validadores:</strong> El mÃ³dulo <code>validadores.py</code> seguirÃ¡ funcionando igual â€” la validaciÃ³n no cambia porque la peticiÃ³n sea asÃ­ncrona.</li>
                <li><strong>Timeout configurado:</strong> Tu TIMEOUT de 10 segundos ahora se aplica a cada peticiÃ³n independiente, permitiendo que unas terminen mientras otras esperan.</li>
            </ul>
        </section>

        <!-- ========== ERRORES COMUNES ========== -->
        <section class="errores-comunes-box">
            <h3>âš ï¸ Errores comunes esta semana (que la IA podrÃ­a no detectar)</h3>
            <ul class="errores-lista">
                <li>
                    <strong>No cerrar la sesiÃ³n HTTP asÃ­ncrona (<code>aiohttp.ClientSession</code>):</strong>
                    La IA genera cÃ³digo que crea sesiones pero olvida cerrarlas. Cada sesiÃ³n abierta consume recursos del sistema operativo. DespuÃ©s de 100 peticiones, tu programa se queda sin file descriptors.
                </li>
                <li>
                    <strong>Usar <code>asyncio.gather()</code> sin <code>return_exceptions=True</code>:</strong>
                    Por defecto, si UNA tarea de <code>gather</code> lanza una excepciÃ³n, TODAS se cancelan y se pierde el trabajo completado. La IA suele generar el caso optimista.
                </li>
                <li>
                    <strong>Mezclar cÃ³digo sÃ­ncrono con asÃ­ncrono:</strong>
                    Llamar a <code>requests.get()</code> (sÃ­ncrono) dentro de una funciÃ³n <code>async</code> bloquea todo el event loop. La IA puede generar cÃ³digo que "funciona" pero anula los beneficios de la asincronÃ­a.
                </li>
                <li>
                    <strong>No manejar <code>asyncio.TimeoutError</code> separado de otros errores:</strong>
                    Un timeout no es lo mismo que un error de conexiÃ³n o un 500. Requiere estrategia diferente (Â¿reintentar? Â¿abortar? Â¿usar cachÃ©?). La IA tiende a agrupar todos los errores en un solo <code>except</code>.
                </li>
            </ul>
        </section>

        <!-- ========== FASE 1: COMPRENDE ========== -->
        <section id="comprende" class="fase-section">
            <div class="fase-header" data-fase="comprende">
                <div class="fase-numero">1</div>
                <div class="fase-info">
                    <h2 class="fase-nombre">COMPRENDE</h2>
                    <p class="fase-bloom">Nivel Bloom: <strong>Recordar / Comprender</strong></p>
                </div>
                <div class="fase-tiempo">
                    <span>â±ï¸</span>
                    <span>45 minutos</span>
                </div>
            </div>

            <div class="objetivos-box">
                <h3 class="objetivos-titulo">
                    <span>ğŸ¯</span>
                    Objetivos de Aprendizaje
                </h3>
                <ul class="objetivos-lista">
                    <li>Explicar la diferencia entre ejecuciÃ³n sÃ­ncrona, concurrente y paralela</li>
                    <li>Describir los tres modelos de asincronÃ­a: callbacks, Promises/Futures, async/await</li>
                    <li>Identificar cuÃ¡ndo la ejecuciÃ³n concurrente mejora el rendimiento de un cliente HTTP</li>
                    <li>Reconocer el papel del event loop como orquestador de tareas no bloqueantes</li>
                </ul>
            </div>

            <div class="contenido-section">
                <h3>SÃ­ncrono vs. Concurrente vs. Paralelo</h3>
                <p>
                    Estos tres tÃ©rminos se confunden constantemente. Entender su diferencia es crucial 
                    para tomar decisiones correctas sobre cÃ³mo estructurar tu cliente HTTP.
                </p>

                <div class="diagrama-container">
                    <div class="diagrama-ascii">
<span class="diagrama-titulo">â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚            SÃNCRONO vs. CONCURRENTE vs. PARALELO              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</span>

    SÃNCRONO (tu cliente actual)
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    Hilo Ãºnico, una tarea a la vez:

    Tiempo â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º

    Hilo 1: â–“â–“â–“â–“ GET /productos â–“â–“â–“â–“ â”‚ espera â”‚ â–“â–“â–“â–“ GET /categorias â–“â–“â–“â–“ â”‚ esp â”‚
                                                 â–²
                                                 â”‚
                                          El hilo estÃ¡ BLOQUEADO
                                          esperando la respuesta
    Total: 500ms + 500ms = 1000ms


    CONCURRENTE (lo que aprenderÃ¡s hoy)
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    Hilo Ãºnico, mÃºltiples tareas intercaladas:

    Tiempo â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º

    Hilo 1: â–“â–“ GET /productos â–“â–“ â†’ espera red â†’ â–“â–“ procesa â–“â–“
                â–“â–“ GET /categorias â–“â–“ â†’ espera red â†’ â–“â–“ procesa â–“â–“
                    â–“â–“ GET /perfil â–“â–“ â†’ espera red â†’ â–“â–“ procesa â–“â–“
            â–²
            â”‚
            Event loop intercala tareas mientras esperan I/O

    Total: ~550ms (se solapan las esperas de red)


    PARALELO (mÃºltiples CPUs)
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    MÃºltiples hilos, ejecuciÃ³n simultÃ¡nea real:

    Tiempo â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º

    Hilo 1: â–“â–“â–“â–“ cÃ¡lculo pesado â–“â–“â–“â–“
    Hilo 2: â–“â–“â–“â–“ cÃ¡lculo pesado â–“â–“â–“â–“
    Hilo 3: â–“â–“â–“â–“ cÃ¡lculo pesado â–“â–“â–“â–“

    Total: tiempo del cÃ¡lculo mÃ¡s lento (no se suman)
                    </div>
                    <div class="diagrama-descripcion">
                        <strong>Idea clave:</strong> Para clientes HTTP, la concurrencia es mÃ¡s Ãºtil que el paralelismo.
                        El cuello de botella es la <em>espera de red</em> (I/O), no el cÃ¡lculo (CPU).
                        El event loop aprovecha esas esperas para lanzar mÃ¡s peticiones.
                    </div>
                </div>

                <div class="caja-contextual caja-warning">
                    <span class="caja-contextual-icon">âš ï¸</span>
                    <div class="caja-contextual-content">
                        <h4>Concurrencia â‰  Paralelismo</h4>
                        <p>La concurrencia es sobre <strong>estructura</strong>: organizar tareas para que progresen intercaladamente. El paralelismo es sobre <strong>ejecuciÃ³n</strong>: hacer cÃ¡lculos simultÃ¡neos en mÃºltiples CPUs. Un cliente HTTP se beneficia de concurrencia (muchas esperas de red), no de paralelismo (poco cÃ¡lculo por peticiÃ³n).</p>
                    </div>
                </div>
            </div>

            <div class="contenido-section">
                <h3>El Event Loop: Director de Orquesta del Cliente</h3>
                <p>
                    El event loop es el mecanismo que permite la concurrencia con un solo hilo.
                    Funciona como un director de orquesta: mientras un mÃºsico descansa (espera de red),
                    dirige a otro que estÃ¡ listo para tocar (procesar respuesta).
                </p>

                <div class="diagrama-container">
                    <div class="diagrama-ascii">
<span class="diagrama-titulo">â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  CICLO DEL EVENT LOOP                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</span>

                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚  INICIO     â”‚
                    â”‚  del loop   â”‚
                    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
                           â”‚
                           â–¼
                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
           â”Œâ”€â”€â”€â–ºâ”‚ Â¿Hay tareas listas?  â”‚
           â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚               â”‚
           â”‚          SÃ­   â”‚   No
           â”‚        â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”
           â”‚        â–¼             â–¼
           â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
           â”‚  â”‚ Ejecutar   â”‚  â”‚ Â¿Hay tareas  â”‚
           â”‚  â”‚ siguiente  â”‚  â”‚  pendientes? â”‚
           â”‚  â”‚ tarea listaâ”‚  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚  â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜     SÃ­  â”‚  No
           â”‚        â”‚          â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”
           â”‚        â”‚          â–¼           â–¼
           â”‚        â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”
           â”‚        â”‚    â”‚ Esperar  â”‚  â”‚  FIN   â”‚
           â”‚        â”‚    â”‚ evento   â”‚  â”‚ (todas â”‚
           â”‚        â”‚    â”‚ de I/O   â”‚  â”‚ comple-â”‚
           â”‚        â”‚    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜  â”‚ tadas) â”‚
           â”‚        â”‚         â”‚        â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚        â–¼         â–¼
           â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
           â””â”€â”€â”€â”€â”¤ Volver al inicio â”‚
                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

    EJEMPLO CON 3 PETICIONES HTTP:

    Paso 1: Lanza GET /productos      â†’ va a la red (pendiente)
    Paso 2: Lanza GET /categorias     â†’ va a la red (pendiente)
    Paso 3: Lanza GET /perfil         â†’ va a la red (pendiente)
    Paso 4: Espera... llega respuesta de /categorias (la mÃ¡s rÃ¡pida)
    Paso 5: Procesa /categorias       â†’ validar, transformar
    Paso 6: Espera... llega respuesta de /productos
    Paso 7: Procesa /productos        â†’ validar, transformar
    Paso 8: Espera... llega respuesta de /perfil
    Paso 9: Procesa /perfil           â†’ validar, transformar
    Paso 10: Todas completas â†’ FIN
                    </div>
                    <div class="diagrama-descripcion">
                        <strong>ObservaciÃ³n clave:</strong> El event loop nunca estÃ¡ ocioso mientras haya 
                        trabajo por hacer. Cuando una peticiÃ³n espera respuesta de red, el loop atiende 
                        otra tarea lista. Esto maximiza el uso del hilo Ãºnico sin necesidad de hilos adicionales.
                    </div>
                </div>
            </div>

            <div class="contenido-section">
                <h3>Tres Modelos de AsincronÃ­a: EvoluciÃ³n HistÃ³rica</h3>
                <p>
                    La programaciÃ³n asÃ­ncrona ha evolucionado para ser cada vez mÃ¡s legible.
                    Entender los tres modelos te permite trabajar con cualquier lenguaje y API.
                </p>

                <div class="diagrama-container">
                    <div class="diagrama-ascii">
<span class="diagrama-titulo">â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         EVOLUCIÃ“N DE MODELOS DE ASINCRONÃA                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</span>

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  MODELO 1: CALLBACKS (mÃ¡s antiguo)                      â”‚
    â”‚                                                         â”‚
    â”‚  fetch_productos(callback=procesar_resultado)           â”‚
    â”‚                                                         â”‚
    â”‚  âœ“ Simple para 1 operaciÃ³n                              â”‚
    â”‚  âœ— "Callback hell" con operaciones encadenadas          â”‚
    â”‚  âœ— DifÃ­cil manejar errores de mÃºltiples callbacks       â”‚
    â”‚                                                         â”‚
    â”‚  Lenguajes: JavaScript antiguo, C con libevent          â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚
                        â–¼ Evoluciona a...
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  MODELO 2: PROMISES / FUTURES (intermedio)              â”‚
    â”‚                                                         â”‚
    â”‚  futuro = fetch_productos()                             â”‚
    â”‚  futuro.then(procesar).catch(manejar_error)             â”‚
    â”‚                                                         â”‚
    â”‚  âœ“ Encadenamiento legible (.then().then())              â”‚
    â”‚  âœ“ Manejo de errores centralizado (.catch())            â”‚
    â”‚  âœ“ ComposiciÃ³n: Promise.all([f1, f2, f3])               â”‚
    â”‚  âœ— Sigue siendo diferente al cÃ³digo sÃ­ncrono            â”‚
    â”‚                                                         â”‚
    â”‚  Lenguajes: JavaScript ES6+, Java (CompletableFuture)   â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚
                        â–¼ Evoluciona a...
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  MODELO 3: ASYNC/AWAIT (moderno)                        â”‚
    â”‚                                                         â”‚
    â”‚  resultado = await fetch_productos()                    â”‚
    â”‚                                                         â”‚
    â”‚  âœ“ Parece cÃ³digo sÃ­ncrono                               â”‚
    â”‚  âœ“ try/except funciona normalmente                      â”‚
    â”‚  âœ“ FÃ¡cil de razonar y depurar                           â”‚
    â”‚  âœ“ ComposiciÃ³n: await gather(f1(), f2(), f3())          â”‚
    â”‚  âœ— Requiere entender el event loop subyacente           â”‚
    â”‚                                                         â”‚
    â”‚  Lenguajes: Python 3.5+, JavaScript ES2017, C#, Rust    â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    </div>
                    <div class="diagrama-descripcion">
                        <strong>Nota histÃ³rica:</strong> Los tres modelos resuelven el mismo problema 
                        (no bloquear mientras se espera I/O), pero con diferente ergonomÃ­a. 
                        <code>async/await</code> es la sintaxis dominante en lenguajes modernos porque 
                        permite escribir cÃ³digo asÃ­ncrono que <em>se lee</em> como sÃ­ncrono.
                    </div>
                </div>

                <div class="caja-contextual caja-tip">
                    <span class="caja-contextual-icon">ğŸ’¡</span>
                    <div class="caja-contextual-content">
                        <h4>Principio de Transferibilidad</h4>
                        <p>Si entiendes <code>async/await</code> en Python, puedes aplicarlo en JavaScript, C#, Rust o Kotlin. Los nombres cambian, pero el patrÃ³n es idÃ©ntico: marcar funciones como <code>async</code>, usar <code>await</code> para esperar resultados, y componer con equivalentes de <code>gather</code>.</p>
                    </div>
                </div>
            </div>

            <!-- RETO IA #1 - ESENCIAL -->
            <div class="reto-ia">
                <div class="reto-ia-header">
                    <div class="reto-ia-badge">
                        <span class="reto-ia-numero">1</span>
                        <span>RETO IA</span>
                    </div>
                    <span class="reto-tipo-tag esencial">â­ ESENCIAL</span>
                </div>
                <h3 class="reto-ia-titulo">CartÃ³grafo de Modelos de Concurrencia</h3>
                <div class="reto-ia-rol">
                    <p class="reto-ia-rol-label">Rol asignado a la IA</p>
                    <p class="reto-ia-rol-text">ğŸ§  Instructor de Sistemas Concurrentes</p>
                </div>
                <div class="prompt-container">
                    <p class="prompt-label">
                        <span>ğŸ“‹</span>
                        <span>PROMPT COMPLETO</span>
                    </p>
                    <p class="prompt-text">ActÃºa como un instructor especializado en sistemas concurrentes que me ayudarÃ¡ a entender los modelos de asincronÃ­a aplicados a clientes HTTP.

<em>Contexto:</em> Tengo un cliente HTTP sÃ­ncrono para EcoMarket (Python con requests) que hace peticiones secuenciales. Necesito entender cÃ³mo convertirlo en concurrente.

<em>Tu tarea:</em>
MuÃ©strame el MISMO escenario â€” cargar simultÃ¡neamente productos, categorÃ­as y perfil de usuario â€” implementado con los 3 modelos:

1. <em>Callbacks</em> (usando concurrent.futures con callbacks):
   - CÃ³mo se lanza cada peticiÃ³n
   - CÃ³mo se recibe el resultado vÃ­a callback
   - QuÃ© pasa si una peticiÃ³n falla: Â¿se enteran las demÃ¡s?

2. <em>Futures</em> (usando concurrent.futures.ThreadPoolExecutor):
   - CÃ³mo se obtienen los Future objects
   - CÃ³mo se espera a que todos terminen
   - CÃ³mo se maneja el error de UN future sin perder los demÃ¡s

3. <em>Async/Await</em> (usando asyncio + aiohttp):
   - CÃ³mo se define una funciÃ³n async
   - CÃ³mo se usa gather() para lanzar todo en paralelo
   - CÃ³mo se maneja el error individual con return_exceptions

<em>Para cada modelo incluye:</em>
- CÃ³digo Python completo y ejecutable
- Diagrama temporal mostrando quÃ© pasa en cada milisegundo
- Ventajas y desventajas especÃ­ficas para clientes HTTP
- QuÃ© pasa cuando la peticiÃ³n de /categorias falla con timeout

<em>RestricciÃ³n:</em> Usa las mismas URLs y datos de EcoMarket en los 3 ejemplos para que la comparaciÃ³n sea directa.</p>
                </div>
                <div class="reto-ia-instrucciones">
                    <h4><span>ğŸ“</span> Instrucciones</h4>
                    <ol>
                        <li>Antes de enviar el prompt, dibuja en papel cÃ³mo <em>crees</em> que funciona el event loop</li>
                        <li>Ejecuta los 3 ejemplos y mide el tiempo de cada uno con <code>time.time()</code></li>
                        <li>Simula un timeout en la peticiÃ³n de /categorias y observa quÃ© modelo lo maneja mejor</li>
                        <li>Escribe en 3 oraciones cuÃ¡l modelo elegirÃ­as y por quÃ©</li>
                    </ol>
                </div>
                <div class="reto-ia-entregable">
                    <h4><span>ğŸ“¦</span> Entregable</h4>
                    <p>Tabla comparativa de los 3 modelos con tiempos medidos. JustificaciÃ³n de 1 pÃ¡rrafo explicando cuÃ¡l modelo usarÃ¡s para EcoMarket y por quÃ©.</p>
                </div>
            </div>

            <!-- RETO IA #2 - ESENCIAL -->
            <div class="reto-ia">
                <div class="reto-ia-header">
                    <div class="reto-ia-badge">
                        <span class="reto-ia-numero">2</span>
                        <span>RETO IA</span>
                    </div>
                    <span class="reto-tipo-tag esencial">â­ ESENCIAL</span>
                </div>
                <h3 class="reto-ia-titulo">Anatomista del Event Loop</h3>
                <div class="reto-ia-rol">
                    <p class="reto-ia-rol-label">Rol asignado a la IA</p>
                    <p class="reto-ia-rol-text">ğŸ”¬ Experto en Internals de asyncio</p>
                </div>
                <div class="prompt-container">
                    <p class="prompt-label">
                        <span>ğŸ“‹</span>
                        <span>PROMPT COMPLETO</span>
                    </p>
                    <p class="prompt-text">ActÃºa como un experto en los internals de asyncio que me explicarÃ¡ paso a paso quÃ© sucede cuando ejecuto cÃ³digo asÃ­ncrono.

<em>Contexto:</em> Entiendo quÃ© hace async/await a nivel superficial, pero no entiendo quÃ© pasa "por debajo". Necesito un modelo mental sÃ³lido.

<em>Tu tarea:</em>
Dado este cÃ³digo:
```python
import asyncio
import aiohttp

async def obtener_datos():
    async with aiohttp.ClientSession() as session:
        tarea1 = session.get("http://localhost:3000/api/productos")
        tarea2 = session.get("http://localhost:3000/api/categorias")
        resp1, resp2 = await asyncio.gather(tarea1, tarea2)
        productos = await resp1.json()
        categorias = await resp2.json()
        return productos, categorias

asyncio.run(obtener_datos())
```

ExplÃ­came paso a paso:
1. Â¿QuÃ© pasa cuando se llama a <em>asyncio.run()</em>? Â¿QuÃ© se crea?
2. Â¿QuÃ© pasa en la lÃ­nea <em>session.get()</em>? Â¿Se envÃ­a la peticiÃ³n inmediatamente?
3. Â¿QuÃ© hace <em>asyncio.gather()</em> internamente? Â¿CÃ³mo registra las tareas?
4. Cuando el event loop llega a <em>await gather()</em>, Â¿quÃ© tareas estÃ¡n en quÃ© estado?
5. Si la respuesta de /categorias llega primero, Â¿quÃ© hace el event loop?
6. Â¿En quÃ© momento exacto se ejecuta <em>resp1.json()</em>?
7. Â¿QuÃ© pasa si /productos responde con error 500 durante el gather?

<em>Formato:</em> Usa una lÃ­nea temporal numerada (paso 1, paso 2...) mostrando el estado del event loop en cada momento. Para cada paso indica: quÃ© tarea estÃ¡ EJECUTANDO, cuÃ¡les estÃ¡n ESPERANDO, y cuÃ¡les estÃ¡n COMPLETAS.</p>
                </div>
                <div class="reto-ia-instrucciones">
                    <h4><span>ğŸ“</span> Instrucciones</h4>
                    <ol>
                        <li>Lee la explicaciÃ³n y redibuja la lÃ­nea temporal con tus propias palabras</li>
                        <li>Agrega <code>print()</code> antes y despuÃ©s de cada <code>await</code> en el cÃ³digo</li>
                        <li>Ejecuta el cÃ³digo y compara el orden de los prints con tu predicciÃ³n</li>
                        <li>Identifica al menos una cosa que entendÃ­as mal antes de este ejercicio</li>
                    </ol>
                </div>
                <div class="reto-ia-entregable">
                    <h4><span>ğŸ“¦</span> Entregable</h4>
                    <p>Diagrama temporal redibujado a mano (foto o digital) con anotaciones propias. PÃ¡rrafo explicando quÃ© concepto corregiste despuÃ©s de la experimentaciÃ³n.</p>
                </div>
            </div>

            <!-- CHECKPOINT METACOGNITIVO -->
            <div class="checkpoint-metacognitivo">
                <div class="checkpoint-header">
                    <div class="checkpoint-icon">ğŸª</div>
                    <h3 class="checkpoint-title">Checkpoint Metacognitivo - Fase Comprende</h3>
                </div>
                <ul class="checkpoint-preguntas">
                    <li>Â¿Puedo explicar por quÃ© concurrencia es diferente de paralelismo con un ejemplo de EcoMarket?</li>
                    <li>Si alguien me pregunta "Â¿por quÃ© no usar hilos directamente?", Â¿tengo una respuesta convincente?</li>
                    <li>Â¿Entiendo quÃ© pasa cuando pongo <code>await</code> â€” o solo lo uso porque "asÃ­ funciona"?</li>
                    <li>Â¿PodrÃ­a dibujar el flujo del event loop para 4 peticiones simultÃ¡neas sin consultar notas?</li>
                </ul>
            </div>

            <!-- INVARIANTES -->
            <div class="invariantes-box">
                <div class="invariantes-header">
                    <div class="invariantes-icon">ğŸ›¡ï¸</div>
                    <div>
                        <h3 class="invariantes-title">Invariantes que No Deben Romperse</h3>
                        <p class="invariantes-subtitle">Si la IA sugiere algo que viola estos principios, cuestiona la sugerencia</p>
                    </div>
                </div>
                <ul class="invariantes-lista">
                    <li>
                        <strong>Nunca mezclar <code>requests</code> (sÃ­ncrono) dentro de funciones <code>async</code></strong>
                        Una llamada sÃ­ncrona bloquea TODO el event loop. Usa <code>aiohttp</code> o <code>httpx</code> en modo asÃ­ncrono.
                    </li>
                    <li>
                        <strong>Toda sesiÃ³n HTTP asÃ­ncrona debe cerrarse explÃ­citamente</strong>
                        Usa <code>async with</code> para garantizar el cierre. Si la IA genera cÃ³digo sin context manager, es un resource leak.
                    </li>
                    <li>
                        <strong>El event loop ejecuta una sola tarea a la vez</strong>
                        No hay ejecuciÃ³n paralela real con asyncio (a diferencia de threads). Si la IA sugiere que asyncio ejecuta "en paralelo", es impreciso.
                    </li>
                    <li>
                        <strong><code>await</code> es un punto de cesiÃ³n, no una "espera pasiva"</strong>
                        Cuando haces <code>await</code>, le dices al event loop: "puedes ejecutar otra tarea mientras yo espero". No es simplemente "esperar".
                    </li>
                </ul>
                <div class="invariantes-nota">
                    <span>ğŸ’¡</span>
                    <span>Usa estos invariantes como filtro cuando la IA genere cÃ³digo asÃ­ncrono. El error mÃ¡s comÃºn es generar cÃ³digo que "parece asÃ­ncrono" pero se ejecuta secuencialmente.</span>
                </div>
            </div>
        </section>

        <!-- ========== FASE 2: APLICA ========== -->
        <section id="aplica" class="fase-section">
            <div class="fase-header" data-fase="aplica">
                <div class="fase-numero">2</div>
                <div class="fase-info">
                    <h2 class="fase-nombre">APLICA</h2>
                    <p class="fase-bloom">Nivel Bloom: <strong>Aplicar / Analizar</strong></p>
                </div>
                <div class="fase-tiempo">
                    <span>â±ï¸</span>
                    <span>90 minutos</span>
                </div>
            </div>

            <div class="objetivos-box">
                <h3 class="objetivos-titulo">
                    <span>ğŸ¯</span>
                    Objetivos de Aprendizaje
                </h3>
                <ul class="objetivos-lista">
                    <li>Implementar un cliente HTTP asÃ­ncrono usando <code>aiohttp</code> con operaciones concurrentes</li>
                    <li>Coordinar mÃºltiples peticiones simultÃ¡neas con <code>asyncio.gather()</code></li>
                    <li>Manejar timeouts individuales por peticiÃ³n sin afectar a las demÃ¡s</li>
                    <li>Implementar cancelaciÃ³n de peticiones en curso cuando ya no son necesarias</li>
                </ul>
            </div>

            <div class="caja-contextual caja-success">
                <span class="caja-contextual-icon">ğŸ</span>
                <div class="caja-contextual-content">
                    <h4>Lenguaje de ImplementaciÃ³n: Python con aiohttp</h4>
                    <p>Esta semana usaremos <strong>Python con asyncio y aiohttp</strong>. La elecciÃ³n es deliberada: <code>asyncio</code> expone el event loop de forma explÃ­cita, lo que te obliga a entender <em>cuÃ¡ndo</em> se cede el control y <em>por quÃ©</em>. En JavaScript (con Node.js), el event loop es implÃ­cito y oculta estos mecanismos. En Python, cada <code>await</code> es una decisiÃ³n consciente.</p>
                    <p style="margin-top: 0.5rem;">AdemÃ¡s, la transiciÃ³n de <code>requests</code> (Semana 2) a <code>aiohttp</code> (Semana 3) te enseÃ±a un patrÃ³n transferible: cÃ³mo migrar cÃ³digo sÃ­ncrono a asÃ­ncrono conservando la lÃ³gica de negocio.</p>
                </div>
            </div>

            <div class="contenido-section">
                <h3>Arquitectura del Cliente AsÃ­ncrono</h3>
                <p>
                    El cliente asÃ­ncrono mantiene la misma estructura modular de la Semana 2, 
                    pero reemplaza el motor de ejecuciÃ³n: en lugar de <code>requests</code> (bloqueante), 
                    usa <code>aiohttp</code> (no bloqueante) dentro de un event loop.
                </p>

                <div class="diagrama-container">
                    <div class="diagrama-ascii">
<span class="diagrama-titulo">â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          ARQUITECTURA: SÃNCRONO â†’ ASÃNCRONO                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</span>

    SEMANA 2 (SÃ­ncrono)              SEMANA 3 (AsÃ­ncrono)
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•              â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚   requests      â”‚  â”€â”€â”€â”€â”€â”€â–º     â”‚   aiohttp       â”‚
    â”‚   (bloqueante)  â”‚              â”‚   (no-bloquea)  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚                                â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ listar_productosâ”‚  â”€â”€â”€â”€â”€â”€â–º     â”‚async listar_    â”‚
    â”‚ obtener_productoâ”‚              â”‚      productos  â”‚
    â”‚ crear_producto  â”‚              â”‚async obtener_   â”‚
    â”‚ ...             â”‚              â”‚      producto   â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚                                â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ validadores.py  â”‚  (SIN CAMBIO)â”‚ validadores.py  â”‚
    â”‚ (mismo mÃ³dulo)  â”‚ â—„â•â•â•â•â•â•â•â•â•â•â–º â”‚ (mismo mÃ³dulo)  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚                                â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ Manejo errores  â”‚  â”€â”€â”€â”€â”€â”€â–º     â”‚ Manejo errores          â”‚
    â”‚ (excepciones)   â”‚              â”‚ + TimeoutError          â”‚
    â”‚                 â”‚              â”‚ + CancelledError        â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚ + errores por peticiÃ³n  â”‚
                                     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

    NUEVO: Capa de coordinaciÃ³n
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  Coordinador de Peticiones               â”‚
    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
    â”‚  â”‚ gather() â”‚ â”‚ wait()   â”‚ â”‚as_compl- â”‚ â”‚
    â”‚  â”‚ todas    â”‚ â”‚ primeras â”‚ â”‚eted()    â”‚ â”‚
    â”‚  â”‚ juntas   â”‚ â”‚ N de M   â”‚ â”‚ orden de â”‚ â”‚
    â”‚  â”‚          â”‚ â”‚          â”‚ â”‚ llegada  â”‚ â”‚
    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    </div>
                    <div class="diagrama-descripcion">
                        <strong>Cambio clave:</strong> Los validadores NO cambian. La lÃ³gica de negocio NO cambia.
                        Solo cambia el <em>motor de transporte</em> (requests â†’ aiohttp) y se agrega una capa
                        de coordinaciÃ³n para manejar mÃºltiples peticiones simultÃ¡neas.
                    </div>
                </div>
            </div>

            <div class="contenido-section">
                <h3>CÃ³digo Base: Cliente AsÃ­ncrono con aiohttp</h3>
                <p>
                    Observa cÃ³mo la estructura es casi idÃ©ntica al cliente sÃ­ncrono de la Semana 2.
                    Las diferencias estÃ¡n marcadas con comentarios.
                </p>

                <div class="codigo-bloque">
                    <div class="codigo-header">
                        <span class="codigo-lenguaje">Python</span>
                        <span class="codigo-archivo">cliente_async_ecomarket.py (esqueleto)</span>
                    </div>
                    <pre><span class="keyword">import</span> asyncio
<span class="keyword">import</span> aiohttp
<span class="keyword">from</span> validadores <span class="keyword">import</span> validar_producto, validar_lista_productos  <span class="comment"># Â¡Reutilizamos!</span>

<span class="comment"># ConfiguraciÃ³n (misma que Semana 2)</span>
BASE_URL = <span class="string">"http://localhost:3000/api/"</span>
TIMEOUT_POR_PETICION = aiohttp.ClientTimeout(total=<span class="number">10</span>)

<span class="comment"># CAMBIO: Las excepciones se mantienen igual</span>
<span class="keyword">class</span> <span class="function">EcoMarketError</span>(Exception): <span class="keyword">pass</span>
<span class="keyword">class</span> <span class="function">ValidationError</span>(EcoMarketError): <span class="keyword">pass</span>
<span class="keyword">class</span> <span class="function">ServerError</span>(EcoMarketError): <span class="keyword">pass</span>

<span class="comment"># CAMBIO: La sesiÃ³n se pasa como parÃ¡metro (no se crea por peticiÃ³n)</span>
<span class="keyword">async def</span> <span class="function">_verificar_respuesta</span>(response):
    <span class="string">"""Misma lÃ³gica de Semana 2, ahora asÃ­ncrona."""</span>
    <span class="keyword">if</span> response.status >= <span class="number">500</span>:
        <span class="keyword">raise</span> ServerError(f<span class="string">"Error del servidor: {response.status}"</span>)
    <span class="keyword">if</span> response.status >= <span class="number">400</span>:
        <span class="keyword">raise</span> ValidationError(f<span class="string">"Error de cliente: {response.status}"</span>)
    
    content_type = response.headers.get(<span class="string">'Content-Type'</span>, <span class="string">''</span>)
    <span class="keyword">if</span> <span class="string">'application/json'</span> <span class="keyword">not in</span> content_type:
        <span class="keyword">if</span> response.status != <span class="number">204</span>:
            <span class="keyword">raise</span> ValidationError(f<span class="string">"No es JSON: {content_type}"</span>)
    <span class="keyword">return</span> response

<span class="comment"># CAMBIO: async def en lugar de def, session como parÃ¡metro</span>
<span class="keyword">async def</span> <span class="function">listar_productos</span>(session, categoria=<span class="keyword">None</span>):
    <span class="string">"""GET /productos - ahora no-bloqueante."""</span>
    params = {}
    <span class="keyword">if</span> categoria:
        params[<span class="string">'categoria'</span>] = categoria
    
    <span class="comment"># CAMBIO: await en lugar de llamada directa</span>
    <span class="keyword">async with</span> session.get(
        f<span class="string">"{BASE_URL}productos"</span>, params=params
    ) <span class="keyword">as</span> response:
        <span class="keyword">await</span> _verificar_respuesta(response)
        datos = <span class="keyword">await</span> response.json()  <span class="comment"># await: leer body es I/O</span>
        <span class="keyword">return</span> validar_lista_productos(datos)

<span class="comment"># NUEVO: FunciÃ³n de coordinaciÃ³n para cargar dashboard</span>
<span class="keyword">async def</span> <span class="function">cargar_dashboard</span>():
    <span class="string">"""Carga productos, categorÃ­as y perfil en paralelo."""</span>
    <span class="keyword">async with</span> aiohttp.ClientSession(
        timeout=TIMEOUT_POR_PETICION
    ) <span class="keyword">as</span> session:
        resultados = <span class="keyword">await</span> asyncio.gather(
            listar_productos(session),
            obtener_categorias(session),  <span class="comment"># TODO: implementar</span>
            obtener_perfil(session),      <span class="comment"># TODO: implementar</span>
            return_exceptions=<span class="keyword">True</span>       <span class="comment"># â† CRÃTICO: no perder todo si una falla</span>
        )
        <span class="keyword">return</span> _procesar_resultados(resultados)

<span class="comment"># TODO: Implementar obtener_categorias, obtener_perfil,</span>
<span class="comment">#       crear_producto_async, _procesar_resultados</span></pre>
                </div>
            </div>

            <!-- RETO IA #3 - ESENCIAL -->
            <div class="reto-ia">
                <div class="reto-ia-header">
                    <div class="reto-ia-badge">
                        <span class="reto-ia-numero">3</span>
                        <span>RETO IA</span>
                    </div>
                    <span class="reto-tipo-tag esencial">â­ ESENCIAL</span>
                </div>
                <h3 class="reto-ia-titulo">Migrador SÃ­ncrono â†’ AsÃ­ncrono</h3>
                <div class="reto-ia-rol">
                    <p class="reto-ia-rol-label">Rol asignado a la IA</p>
                    <p class="reto-ia-rol-text">ğŸ”„ Especialista en MigraciÃ³n de CÃ³digo AsÃ­ncrono</p>
                </div>
                <div class="prompt-container">
                    <p class="prompt-label">
                        <span>ğŸ“‹</span>
                        <span>PROMPT COMPLETO</span>
                    </p>
                    <p class="prompt-text">ActÃºa como un especialista en migraciÃ³n de cÃ³digo sÃ­ncrono a asÃ­ncrono en Python. Necesito convertir mi cliente HTTP de EcoMarket.

<em>Contexto:</em> Tengo un cliente sÃ­ncrono (Semana 2) con estas funciones usando requests:
- listar_productos(categoria, orden) â†’ GET
- obtener_producto(producto_id) â†’ GET
- crear_producto(datos) â†’ POST
- actualizar_producto_total(producto_id, datos) â†’ PUT
- actualizar_producto_parcial(producto_id, campos) â†’ PATCH
- eliminar_producto(producto_id) â†’ DELETE

Todas usan la misma estructura: construir URL â†’ ejecutar peticiÃ³n â†’ verificar respuesta â†’ validar datos â†’ retornar.

<em>Tu tarea:</em>
1. Convierte CADA funciÃ³n a su versiÃ³n asÃ­ncrona usando aiohttp:
   - Marca como async def
   - Recibe session como primer parÃ¡metro
   - Usa async with session.METHOD() as response
   - Usa await para response.json()
   - Mantiene los mismos validadores (no cambian)
   - Mantiene las mismas excepciones personalizadas

2. Crea la funciÃ³n <em>cargar_dashboard()</em> que:
   - Crea UNA sola ClientSession (no una por peticiÃ³n)
   - Ejecuta en paralelo: listar_productos + obtener_categorias + obtener_perfil
   - Usa return_exceptions=True en gather
   - Procesa los resultados separando Ã©xitos de errores
   - Retorna un dict con los datos cargados y los errores encontrados

3. Crea la funciÃ³n <em>crear_multiples_productos(lista_productos)</em> que:
   - Recibe una lista de dicts con datos de productos
   - Crea todos los productos en paralelo
   - Retorna: (productos_creados, productos_fallidos)
   - Limita a mÃ¡ximo 5 peticiones simultÃ¡neas (semÃ¡foro)

4. Incluye manejo especÃ­fico de:
   - aiohttp.ClientTimeout â†’ peticiÃ³n lenta
   - asyncio.CancelledError â†’ tarea cancelada
   - aiohttp.ClientConnectorError â†’ servidor inalcanzable

<em>Requisito:</em> Conservar toda la validaciÃ³n de la Semana 2 sin modificarla.</p>
                </div>
                <div class="reto-ia-instrucciones">
                    <h4><span>ğŸ“</span> Instrucciones</h4>
                    <ol>
                        <li>Antes de enviar el prompt, intenta convertir <code>listar_productos</code> tÃº mismo</li>
                        <li>Compara tu versiÃ³n con la de la IA â€” Â¿olvidaste algÃºn <code>await</code>?</li>
                        <li>Ejecuta <code>cargar_dashboard()</code> contra tu mock server y mide el tiempo total</li>
                        <li>Compara con la versiÃ³n sÃ­ncrona: Â¿cuÃ¡nto mÃ¡s rÃ¡pido es?</li>
                        <li>Prueba <code>crear_multiples_productos()</code> con 20 productos y verifica que el semÃ¡foro funciona</li>
                    </ol>
                </div>
                <div class="reto-ia-entregable">
                    <h4><span>ğŸ“¦</span> Entregable</h4>
                    <p>Archivo <span class="codigo-inline">cliente_async_ecomarket.py</span> completo con todas las funciones migradas. MediciÃ³n de tiempos: sÃ­ncrono vs. asÃ­ncrono para cargar_dashboard().</p>
                </div>
            </div>

            <!-- RETO IA #4 - ESENCIAL -->
            <div class="reto-ia">
                <div class="reto-ia-header">
                    <div class="reto-ia-badge">
                        <span class="reto-ia-numero">4</span>
                        <span>RETO IA</span>
                    </div>
                    <span class="reto-tipo-tag esencial">â­ ESENCIAL</span>
                </div>
                <h3 class="reto-ia-titulo">Ingeniero de Timeouts y CancelaciÃ³n</h3>
                <div class="reto-ia-rol">
                    <p class="reto-ia-rol-label">Rol asignado a la IA</p>
                    <p class="reto-ia-rol-text">â±ï¸ Especialista en Control de Flujo AsÃ­ncrono</p>
                </div>
                <div class="prompt-container">
                    <p class="prompt-label">
                        <span>ğŸ“‹</span>
                        <span>PROMPT COMPLETO</span>
                    </p>
                    <p class="prompt-text">ActÃºa como un especialista en control de flujo asÃ­ncrono. Necesito implementar timeout y cancelaciÃ³n granular en mi cliente.

<em>Contexto:</em> Mi cliente asÃ­ncrono de EcoMarket puede lanzar mÃºltiples peticiones con gather(). Pero necesito controlar quÃ© pasa cuando:
- Una peticiÃ³n tarda demasiado
- El usuario cancela la operaciÃ³n
- Necesito solo las primeras N respuestas que lleguen

<em>Tu tarea:</em>
1. Implementa <em>timeout individual por peticiÃ³n</em>:
   - Crea un wrapper async que envuelva cualquier peticiÃ³n con asyncio.wait_for()
   - Si una peticiÃ³n excede SU timeout, las demÃ¡s continÃºan normalmente
   - El timeout debe ser configurable por funciÃ³n (no global)
   - Ejemplo: productos=5s, categorÃ­as=3s, perfil=2s

2. Implementa <em>cancelaciÃ³n de tareas en grupo</em>:
   - FunciÃ³n cancel_remaining(tareas) que cancela tareas pendientes
   - Escenario: si la peticiÃ³n de perfil falla con 401 (no autorizado), cancela las demÃ¡s (no tiene sentido continuar sin autenticaciÃ³n)
   - Maneja CancelledError en cada tarea cancelada

3. Implementa <em>cargar_con_prioridad()</em> usando asyncio.wait():
   - Lanza 4 peticiones simultÃ¡neas
   - Procesa resultados conforme llegan (no espera a todas)
   - Si las 2 peticiones crÃ­ticas (productos y perfil) llegan, muestra el dashboard parcial
   - Las peticiones secundarias (categorÃ­as, notificaciones) se procesan cuando lleguen

4. Para cada implementaciÃ³n incluye:
   - CÃ³digo Python con aiohttp
   - Test que demuestre el comportamiento
   - Diagrama temporal de quÃ© pasa cuando una peticiÃ³n se cancela/timeout

<em>RestricciÃ³n:</em> No uses bibliotecas externas de retry/timeout. Solo asyncio y aiohttp.</p>
                </div>
                <div class="reto-ia-instrucciones">
                    <h4><span>ğŸ“</span> Instrucciones</h4>
                    <ol>
                        <li>Configura tu mock server para que /categorias tenga un delay de 8 segundos</li>
                        <li>Ejecuta con timeout individual de 3s para categorÃ­as y verifica que las demÃ¡s peticiones completan</li>
                        <li>Simula un 401 en /perfil y verifica que las tareas restantes se cancelan</li>
                        <li>Implementa <code>cargar_con_prioridad()</code> y verifica que muestra datos parciales</li>
                    </ol>
                </div>
                <div class="reto-ia-entregable">
                    <h4><span>ğŸ“¦</span> Entregable</h4>
                    <p>MÃ³dulo <span class="codigo-inline">coordinador_async.py</span> con las 3 estrategias implementadas. Log mostrando el comportamiento de cada estrategia ante fallas simuladas.</p>
                </div>
            </div>

            <!-- RETO IA #5 - AVANZADO -->
            <div class="reto-ia reto-avanzado">
                <div class="reto-ia-header">
                    <div class="reto-ia-badge badge-avanzado">
                        <span class="reto-ia-numero">5</span>
                        <span>RETO IA</span>
                    </div>
                    <span class="reto-tipo-tag avanzado">ğŸš€ AVANZADO</span>
                </div>
                <h3 class="reto-ia-titulo">Constructor de SemÃ¡foro con Rate Limiting</h3>
                <div class="reto-ia-rol">
                    <p class="reto-ia-rol-label">Rol asignado a la IA</p>
                    <p class="reto-ia-rol-text">ğŸš¦ Ingeniero de Control de TrÃ¡fico</p>
                </div>
                <div class="prompt-container">
                    <p class="prompt-label">
                        <span>ğŸ“‹</span>
                        <span>PROMPT COMPLETO</span>
                    </p>
                    <p class="prompt-text">ActÃºa como un ingeniero de control de trÃ¡fico que diseÃ±a limitadores de concurrencia para clientes HTTP.

<em>Problema:</em> Mi funciÃ³n crear_multiples_productos() puede lanzar 100 peticiones POST simultÃ¡neas. Esto puede:
- Sobrecargar el servidor (que tiene lÃ­mite de 20 conexiones)
- Agotar los file descriptors del cliente
- Violar rate limits del API (mÃ¡ximo 30 peticiones por segundo)

<em>Tu tarea:</em>
1. Implementa un <em>ConcurrencyLimiter</em> usando asyncio.Semaphore:
   - MÃ¡ximo N peticiones simultÃ¡neas (configurable)
   - Usa context manager: async with limiter.acquire()
   - Logging de cuÃ¡ntas peticiones estÃ¡n en vuelo

2. Implementa un <em>RateLimiter</em> basado en token bucket:
   - MÃ¡ximo M peticiones por segundo
   - Si se excede, las peticiones esperan (no se rechazan)
   - Muestra cuÃ¡nto tiempo cada peticiÃ³n esperÃ³ en cola

3. Combina ambos en un <em>ThrottledClient</em>:
   - Respeta AMBOS lÃ­mites simultÃ¡neamente
   - Permite configurar: max_concurrent=10, max_per_second=20
   - Integra con las funciones CRUD existentes

4. Demuestra con un test:
   - Lanza 50 peticiones de creaciÃ³n de productos
   - Verifica que nunca hay mÃ¡s de 10 en vuelo
   - Verifica que no se exceden 20 por segundo
   - Mide el tiempo total y compara con "sin lÃ­mites"

<em>Requisito:</em> El limitador debe ser un decorador o context manager reutilizable, no lÃ³gica incrustada en las funciones CRUD.</p>
                </div>
                <div class="reto-ia-instrucciones">
                    <h4><span>ğŸ“</span> Instrucciones</h4>
                    <ol>
                        <li>Implementa primero solo el Semaphore y pruÃ©balo con 50 peticiones</li>
                        <li>Agrega el RateLimiter y verifica con logs los tiempos de espera</li>
                        <li>Mide el throughput real (peticiones/segundo) y compara con el lÃ­mite configurado</li>
                        <li>Documenta quÃ© pasa si el servidor es mÃ¡s lento que tu rate limit</li>
                    </ol>
                </div>
                <div class="reto-ia-entregable">
                    <h4><span>ğŸ“¦</span> Entregable</h4>
                    <p>MÃ³dulo <span class="codigo-inline">throttle.py</span> con ConcurrencyLimiter, RateLimiter y ThrottledClient. GrÃ¡fica (o tabla) mostrando peticiones en vuelo vs. tiempo.</p>
                </div>
            </div>

            <!-- CHECKPOINT METACOGNITIVO -->
            <div class="checkpoint-metacognitivo">
                <div class="checkpoint-header">
                    <div class="checkpoint-icon">ğŸª</div>
                    <h3 class="checkpoint-title">Checkpoint Metacognitivo - Fase Aplica</h3>
                </div>
                <ul class="checkpoint-preguntas">
                    <li>Â¿Puedo migrar una nueva funciÃ³n sÃ­ncrona a asÃ­ncrona sin consultar a la IA?</li>
                    <li>Â¿Entiendo por quÃ© la sesiÃ³n se pasa como parÃ¡metro en lugar de crearla en cada funciÃ³n?</li>
                    <li>Â¿Puedo explicar quÃ© hace <code>return_exceptions=True</code> y por quÃ© es crÃ­tico?</li>
                    <li>Si la IA generÃ³ un <code>await</code> que no entiendo, Â¿lo investigo o lo dejo?</li>
                </ul>
            </div>

            <!-- INVARIANTES -->
            <div class="invariantes-box">
                <div class="invariantes-header">
                    <div class="invariantes-icon">ğŸ›¡ï¸</div>
                    <div>
                        <h3 class="invariantes-title">Invariantes que No Deben Romperse</h3>
                        <p class="invariantes-subtitle">Verifica que tu cÃ³digo asÃ­ncrono respeta estos principios</p>
                    </div>
                </div>
                <ul class="invariantes-lista">
                    <li>
                        <strong>Una sola ClientSession por grupo de peticiones relacionadas</strong>
                        Crear una sesiÃ³n por peticiÃ³n desperdicia conexiones TCP. Si la IA genera <code>aiohttp.ClientSession()</code> dentro de cada funciÃ³n, refactoriza.
                    </li>
                    <li>
                        <strong>Siempre usar <code>return_exceptions=True</code> en gather() cuando las tareas son independientes</strong>
                        Sin esto, el fallo de UNA peticiÃ³n cancela TODAS las demÃ¡s y pierdes trabajo completado.
                    </li>
                    <li>
                        <strong>Manejar <code>asyncio.CancelledError</code> para cleanup, nunca suprimirlo</strong>
                        Si una tarea se cancela, debe liberar recursos. Suprimir CancelledError causa resource leaks.
                    </li>
                    <li>
                        <strong>El semÃ¡foro limita concurrencia, no reemplaza el manejo de errores</strong>
                        Con o sin semÃ¡foro, cada peticiÃ³n debe manejar sus propios errores individualmente.
                    </li>
                </ul>
                <div class="invariantes-nota">
                    <span>ğŸ’¡</span>
                    <span>Regla rÃ¡pida: si tu cÃ³digo asÃ­ncrono se ve igual que el sÃ­ncrono pero con "async" y "await" pegados, probablemente NO estÃ¡s aprovechando la concurrencia. Debe haber un punto donde lanzas mÃºltiples tareas y las coordinas.</span>
                </div>
            </div>
        </section>

        <!-- ========== FASE 3: REFLEXIONA ========== -->
        <section id="reflexiona" class="fase-section">
            <div class="fase-header" data-fase="reflexiona">
                <div class="fase-numero">3</div>
                <div class="fase-info">
                    <h2 class="fase-nombre">REFLEXIONA</h2>
                    <p class="fase-bloom">Nivel Bloom: <strong>Analizar</strong></p>
                </div>
                <div class="fase-tiempo">
                    <span>â±ï¸</span>
                    <span>45 minutos</span>
                </div>
            </div>

            <div class="objetivos-box">
                <h3 class="objetivos-titulo">
                    <span>ğŸ¯</span>
                    Objetivos de Aprendizaje
                </h3>
                <ul class="objetivos-lista">
                    <li>Analizar cuÃ¡ndo la asincronÃ­a aporta beneficios reales y cuÃ¡ndo aÃ±ade complejidad innecesaria</li>
                    <li>Comparar las estrategias de coordinaciÃ³n (gather, wait, as_completed) y sus trade-offs</li>
                    <li>Justificar la elecciÃ³n del modelo de concurrencia para diferentes escenarios</li>
                    <li>Documentar decisiones de diseÃ±o en un ADR</li>
                </ul>
            </div>

            <div class="contenido-section">
                <h3>Â¿CuÃ¡ndo la AsincronÃ­a es un Error?</h3>
                <p>
                    No todo cÃ³digo debe ser asÃ­ncrono. La asincronÃ­a tiene costos: complejidad, 
                    dificultad para depurar, y un modelo mental mÃ¡s exigente. La pregunta correcta 
                    no es "Â¿puedo hacerlo asÃ­ncrono?" sino "Â¿necesito hacerlo asÃ­ncrono?"
                </p>

                <div class="diagrama-container">
                    <div class="diagrama-ascii">
<span class="diagrama-titulo">â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           MATRIZ: Â¿CUÃNDO USAR ASINCRONÃA?                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</span>

                        CANTIDAD DE PETICIONES
                    Pocas (1-2) â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º Muchas (10+)

           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    Alta   â”‚                          â”‚                          â”‚
           â”‚  SÃNCRONO ESTÃ BIEN      â”‚  ASÃNCRONO NECESARIO     â”‚
LATENCIA   â”‚                          â”‚                          â”‚
TOLERADA   â”‚  â€¢ Script de una vez     â”‚  â€¢ Pero... Â¿por quÃ©     â”‚
           â”‚  â€¢ CLI simple            â”‚    haces 10+ peticiones  â”‚
           â”‚  â€¢ Proceso batch nocturnoâ”‚    con alta tolerancia?  â”‚
           â”‚                          â”‚  â€¢ Revisa tu diseÃ±o      â”‚
           â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
           â”‚                          â”‚                          â”‚
    Baja   â”‚  SÃNCRONO SI ES RÃPIDO   â”‚  ASÃNCRONO OBLIGATORIO   â”‚
           â”‚                          â”‚                          â”‚
           â”‚  â€¢ 1 peticiÃ³n a API      â”‚  â€¢ Dashboard con 4+ APIs â”‚
LATENCIA   â”‚    rÃ¡pida (<100ms)       â”‚  â€¢ Carga de catÃ¡logo     â”‚
TOLERADA   â”‚  â€¢ Pero prepÃ¡rate para   â”‚  â€¢ Notificaciones +      â”‚
           â”‚    migrar si crece       â”‚    datos + perfil        â”‚
           â”‚                          â”‚  â€¢ [TU CASO: EcoMarket]  â”‚
           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    </div>
                    <div class="diagrama-descripcion">
                        <strong>Regla prÃ¡ctica:</strong> Si tu cliente hace 1-2 peticiones y el usuario tolera 
                        la espera, el cÃ³digo sÃ­ncrono es mÃ¡s simple y correcto. Si necesitas cargar datos de 
                        3+ fuentes con latencia baja, la asincronÃ­a es la herramienta correcta.
                    </div>
                </div>
            </div>

            <!-- RETO IA #6 - ESENCIAL -->
            <div class="reto-ia">
                <div class="reto-ia-header">
                    <div class="reto-ia-badge">
                        <span class="reto-ia-numero">6</span>
                        <span>RETO IA</span>
                    </div>
                    <span class="reto-tipo-tag esencial">â­ ESENCIAL</span>
                </div>
                <h3 class="reto-ia-titulo">CrÃ­tico de Decisiones de Concurrencia</h3>
                <div class="reto-ia-rol">
                    <p class="reto-ia-rol-label">Rol asignado a la IA</p>
                    <p class="reto-ia-rol-text">ğŸ¯ Revisor de Arquitectura Concurrente</p>
                </div>
                <div class="prompt-container">
                    <p class="prompt-label">
                        <span>ğŸ“‹</span>
                        <span>PROMPT COMPLETO</span>
                    </p>
                    <p class="prompt-text">ActÃºa como un revisor de arquitectura especializado en sistemas concurrentes. Voy a presentarte mi cliente asÃ­ncrono y quiero que cuestiones mis decisiones.

<em>Mi cliente tiene estas caracterÃ­sticas:</em>
1. Usa aiohttp con async/await
2. Una sola ClientSession compartida para todo el dashboard
3. asyncio.gather() con return_exceptions=True para peticiones paralelas
4. Timeout individual por peticiÃ³n (configurable)
5. SemÃ¡foro para limitar peticiones simultÃ¡neas a 10
6. Sin reintentos automÃ¡ticos (aÃºn)

<em>Tu tarea:</em>
Para CADA decisiÃ³n, hazme una pregunta socrÃ¡tica:

1. <em>gather() vs. wait() vs. as_completed()</em>
   - Â¿Por quÃ© elegÃ­ gather? Â¿CuÃ¡ndo serÃ­a mejor wait()?
   - Â¿QuÃ© pasa si necesito mostrar datos progresivamente (conforme llegan)?

2. <em>SesiÃ³n compartida vs. sesiÃ³n por peticiÃ³n</em>
   - Â¿QuÃ© beneficio da compartir sesiÃ³n? Â¿Hay riesgos?
   - Â¿QuÃ© pasa si necesito headers diferentes por peticiÃ³n?

3. <em>Timeout individual vs. timeout global</em>
   - Â¿QuÃ© pasa si el timeout de una peticiÃ³n es 10s pero el usuario espera mÃ¡ximo 3s?
   - Â¿DeberÃ­a haber un timeout "de dashboard" que cancele todo?

4. <em>SemÃ¡foro de 10</em>
   - Â¿Por quÃ© 10? Â¿CÃ³mo elegiste ese nÃºmero?
   - Â¿QuÃ© pasa si el servidor puede manejar 100 pero tÃº limitas a 10?

5. <em>Sin reintentos</em>
   - En Semana 2 discutimos reintentos. Â¿Por quÃ© no los implementaste aquÃ­?
   - Â¿El retry y la concurrencia interactÃºan? Â¿PodrÃ­a un retry con backoff complicar el gather?

<em>Formato:</em> Una pregunta a la vez. Espera mi respuesta. Al final, genera un resumen de fortalezas y debilidades.</p>
                </div>
                <div class="reto-ia-instrucciones">
                    <h4><span>ğŸ“</span> Instrucciones</h4>
                    <ol>
                        <li>Responde con honestidad â€” si no tienes justificaciÃ³n sÃ³lida, admÃ­telo</li>
                        <li>Para cada decisiÃ³n, anota: Â¿quÃ© alternativa existe? Â¿quÃ© sacrifico?</li>
                        <li>Documenta en formato ADR las 3 decisiones mÃ¡s importantes</li>
                        <li>Identifica al menos una decisiÃ³n que cambiarÃ­as despuÃ©s de la reflexiÃ³n</li>
                    </ol>
                </div>
                <div class="reto-ia-entregable">
                    <h4><span>ğŸ“¦</span> Entregable</h4>
                    <p>ADR con al menos 3 decisiones de concurrencia documentadas. Cada ADR incluye: Contexto â†’ DecisiÃ³n â†’ Alternativas â†’ Consecuencias.</p>
                </div>
            </div>

            <!-- RETO IA #7 - AVANZADO -->
            <div class="reto-ia reto-avanzado">
                <div class="reto-ia-header">
                    <div class="reto-ia-badge badge-avanzado">
                        <span class="reto-ia-numero">7</span>
                        <span>RETO IA</span>
                    </div>
                    <span class="reto-tipo-tag avanzado">ğŸš€ AVANZADO</span>
                </div>
                <h3 class="reto-ia-titulo">Comparador de Estrategias de CoordinaciÃ³n</h3>
                <div class="reto-ia-rol">
                    <p class="reto-ia-rol-label">Rol asignado a la IA</p>
                    <p class="reto-ia-rol-text">âš–ï¸ Analista de Trade-offs de Concurrencia</p>
                </div>
                <div class="prompt-container">
                    <p class="prompt-label">
                        <span>ğŸ“‹</span>
                        <span>PROMPT COMPLETO</span>
                    </p>
                    <p class="prompt-text">ActÃºa como un analista de trade-offs que compara estrategias de coordinaciÃ³n de tareas asÃ­ncronas.

<em>Contexto:</em> Mi cliente de EcoMarket necesita cargar datos desde 4 endpoints para el dashboard. Quiero entender cuÃ¡l estrategia de coordinaciÃ³n es mejor para cada escenario.

<em>Compara estas 4 estrategias para el caso "cargar dashboard":</em>
1. <em>asyncio.gather()</em> â€” esperar a que TODAS terminen
2. <em>asyncio.wait(return_when=FIRST_COMPLETED)</em> â€” procesar conforme llegan
3. <em>asyncio.as_completed()</em> â€” iterar por orden de completaciÃ³n
4. <em>asyncio.wait(return_when=FIRST_EXCEPTION)</em> â€” abortar ante primer error

<em>Para cada estrategia, analiza:</em>
- Â¿CuÃ¡ndo se muestra el primer dato al usuario?
- Â¿QuÃ© pasa cuando 1 de 4 peticiones falla?
- Â¿QuÃ© pasa cuando 1 de 4 peticiones es muy lenta (10s)?
- Â¿CuÃ¡nto cÃ³digo extra necesita comparado con secuencial?
- Â¿Es fÃ¡cil agregar una 5ta peticiÃ³n despuÃ©s?

<em>Genera:</em>
1. Tabla comparativa con puntuaciÃ³n 1-5 en: latencia percibida, robustez, complejidad, mantenibilidad
2. CÃ³digo Python equivalente para las 4 estrategias
3. Diagrama temporal comparativo para el escenario: productos=200ms, categorÃ­as=100ms, perfil=500ms, notificaciones=TIMEOUT
4. RecomendaciÃ³n especÃ­fica para EcoMarket con justificaciÃ³n

<em>Formato:</em> Tabla + cÃ³digo + diagramas + recomendaciÃ³n.</p>
                </div>
                <div class="reto-ia-instrucciones">
                    <h4><span>ğŸ“</span> Instrucciones</h4>
                    <ol>
                        <li>Implementa las 4 estrategias con el mismo escenario</li>
                        <li>Mide la latencia percibida (tiempo hasta el primer dato visible)</li>
                        <li>Simula un timeout en una peticiÃ³n y compara comportamientos</li>
                        <li>Elige una estrategia para EcoMarket y documenta por quÃ©</li>
                    </ol>
                </div>
                <div class="reto-ia-entregable">
                    <h4><span>ğŸ“¦</span> Entregable</h4>
                    <p>Archivo <span class="codigo-inline">comparacion_coordinacion.py</span> con las 4 estrategias y mediciones. Documento con recomendaciÃ³n justificada para EcoMarket.</p>
                </div>
            </div>

            <!-- CHECKPOINT METACOGNITIVO -->
            <div class="checkpoint-metacognitivo">
                <div class="checkpoint-header">
                    <div class="checkpoint-icon">ğŸª</div>
                    <h3 class="checkpoint-title">Checkpoint Metacognitivo - Fase Reflexiona</h3>
                </div>
                <ul class="checkpoint-preguntas">
                    <li>Â¿CambiÃ© alguna decisiÃ³n de coordinaciÃ³n despuÃ©s de que la IA cuestionara mi razonamiento?</li>
                    <li>Â¿Puedo explicar cuÃ¡ndo gather() NO es la mejor opciÃ³n sin consultar notas?</li>
                    <li>Â¿Hay algÃºn escenario donde mi cÃ³digo sÃ­ncrono de Semana 2 serÃ­a mejor que el asÃ­ncrono?</li>
                    <li>Â¿La reflexiÃ³n me hizo consciente de un trade-off que no habÃ­a considerado?</li>
                </ul>
            </div>

            <!-- INVARIANTES -->
            <div class="invariantes-box">
                <div class="invariantes-header">
                    <div class="invariantes-icon">ğŸ›¡ï¸</div>
                    <div>
                        <h3 class="invariantes-title">Invariantes que No Deben Romperse</h3>
                        <p class="invariantes-subtitle">Principios para decisiones de concurrencia</p>
                    </div>
                </div>
                <ul class="invariantes-lista">
                    <li>
                        <strong>La complejidad asÃ­ncrona debe justificarse con mejora medible</strong>
                        Si el cÃ³digo asÃ­ncrono no es significativamente mÃ¡s rÃ¡pido, el cÃ³digo sÃ­ncrono es preferible por simplicidad.
                    </li>
                    <li>
                        <strong>Toda decisiÃ³n de coordinaciÃ³n tiene un escenario donde es incorrecta</strong>
                        No existe "la mejor" estrategia universal. El contexto determina la elecciÃ³n.
                    </li>
                    <li>
                        <strong>"Porque la IA lo sugiriÃ³" no es justificaciÃ³n de diseÃ±o</strong>
                        Si no puedes explicar POR QUÃ‰ usas gather() en vez de wait(), no entiendes tu propio cÃ³digo.
                    </li>
                </ul>
                <div class="invariantes-nota">
                    <span>ğŸ’¡</span>
                    <span>La mejor seÃ±al de que entiendes la concurrencia es poder explicar cuÃ¡ndo NO usarla.</span>
                </div>
            </div>
        </section>

        <!-- ========== FASE 4: VALIDA ========== -->
        <section id="valida" class="fase-section">
            <div class="fase-header" data-fase="valida">
                <div class="fase-numero">4</div>
                <div class="fase-info">
                    <h2 class="fase-nombre">VALIDA</h2>
                    <p class="fase-bloom">Nivel Bloom: <strong>Evaluar</strong></p>
                </div>
                <div class="fase-tiempo">
                    <span>â±ï¸</span>
                    <span>60 minutos</span>
                </div>
            </div>

            <div class="objetivos-box">
                <h3 class="objetivos-titulo">
                    <span>ğŸ¯</span>
                    Objetivos de Aprendizaje
                </h3>
                <ul class="objetivos-lista">
                    <li>Verificar que el cliente asÃ­ncrono mantiene la correcciÃ³n del sÃ­ncrono (no se perdiÃ³ funcionalidad)</li>
                    <li>Probar escenarios de fallo concurrente: timeouts simultÃ¡neos, cancelaciones en cadena</li>
                    <li>Detectar errores comunes de cÃ³digo asÃ­ncrono: resource leaks, race conditions, deadlocks</li>
                    <li>Medir y comparar rendimiento sÃ­ncrono vs. asÃ­ncrono con datos reales</li>
                </ul>
            </div>

            <div class="contenido-section">
                <h3>Testing de CÃ³digo AsÃ­ncrono: Nuevos DesafÃ­os</h3>
                <p>
                    Probar cÃ³digo asÃ­ncrono introduce desafÃ­os que no existen en cÃ³digo sÃ­ncrono: 
                    el orden de ejecuciÃ³n no es determinista, los errores pueden propagarse de formas 
                    inesperadas, y los resource leaks son mÃ¡s difÃ­ciles de detectar.
                </p>

                <div class="diagrama-container">
                    <div class="diagrama-ascii">
<span class="diagrama-titulo">â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           NUEVOS TIPOS DE BUGS EN CÃ“DIGO ASÃNCRONO             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</span>

    BUG SÃNCRONO                     BUG ASÃNCRONO (NUEVO)
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•                   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ Error en respuesta              â”‚ SesiÃ³n no cerrada       â”‚
    â”‚ (ya lo manejas)  â”‚              â”‚ (resource leak)          â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚ La sesiÃ³n queda abierta  â”‚
                                     â”‚ consumiendo memoria y    â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚ file descriptors          â”‚
    â”‚ Timeout global   â”‚              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â”‚ (ya lo manejas)  â”‚              
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                                     â”‚ Fire-and-forget          â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚ (tarea no esperada)      â”‚
    â”‚ JSON malformado  â”‚              â”‚ Se lanza una coroutine   â”‚
    â”‚ (ya lo manejas)  â”‚              â”‚ sin await â†’ se pierde    â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚ silenciosamente           â”‚
                                     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                     
                                     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                                     â”‚ Gather sin protecciÃ³n    â”‚
                                     â”‚ 1 error cancela todas    â”‚
                                     â”‚ Se pierde trabajo Ãºtil   â”‚
                                     â”‚ ya completado             â”‚
                                     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

                                     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                                     â”‚ Race condition           â”‚
                                     â”‚ Dos tareas modifican     â”‚
                                     â”‚ el mismo estado sin      â”‚
                                     â”‚ sincronizaciÃ³n            â”‚
                                     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    </div>
                    <div class="diagrama-descripcion">
                        <strong>Cambio de mentalidad:</strong> En cÃ³digo sÃ­ncrono, los bugs son reproducibles. 
                        En cÃ³digo asÃ­ncrono, algunos bugs aparecen solo bajo carga o con timing especÃ­fico.
                        Tus tests deben cubrir escenarios de timing, no solo de datos.
                    </div>
                </div>
            </div>

            <!-- RETO IA #8 - ESENCIAL -->
            <div class="reto-ia">
                <div class="reto-ia-header">
                    <div class="reto-ia-badge">
                        <span class="reto-ia-numero">8</span>
                        <span>RETO IA</span>
                    </div>
                    <span class="reto-tipo-tag esencial">â­ ESENCIAL</span>
                </div>
                <h3 class="reto-ia-titulo">DiseÃ±ador de Suite de Pruebas AsÃ­ncronas</h3>
                <div class="reto-ia-rol">
                    <p class="reto-ia-rol-label">Rol asignado a la IA</p>
                    <p class="reto-ia-rol-text">ğŸ§ª Ingeniero de QA para Sistemas Concurrentes</p>
                </div>
                <div class="prompt-container">
                    <p class="prompt-label">
                        <span>ğŸ“‹</span>
                        <span>PROMPT COMPLETO</span>
                    </p>
                    <p class="prompt-text">ActÃºa como un ingeniero de QA especializado en testing de cÃ³digo asÃ­ncrono con Python.

<em>Contexto:</em> Tengo un cliente asÃ­ncrono para EcoMarket con:
- Funciones CRUD asÃ­ncronas (listar, obtener, crear, actualizar, eliminar)
- cargar_dashboard() que ejecuta 3-4 peticiones en paralelo con gather()
- Timeout individual por peticiÃ³n
- SemÃ¡foro para limitar concurrencia

<em>Tu tarea:</em>
DiseÃ±a una suite de pruebas usando pytest + pytest-asyncio + aioresponses que cubra:

1. <em>Equivalencia funcional</em> (5 tests):
   - Las funciones async retornan exactamente lo mismo que las sÃ­ncronas
   - La validaciÃ³n de datos funciona igual
   - Los errores HTTP se manejan igual

2. <em>Concurrencia correcta</em> (5 tests):
   - gather() con 3 peticiones exitosas retorna 3 resultados
   - gather() con 1 fallo y return_exceptions=True retorna 2 Ã©xitos + 1 excepciÃ³n
   - gather() SIN return_exceptions propaga el primer error (test negativo)
   - cargar_dashboard() completa aunque 1 de 4 fuentes falle
   - El semÃ¡foro limita efectivamente la concurrencia

3. <em>Timeouts y cancelaciÃ³n</em> (5 tests):
   - Timeout individual: peticiÃ³n lenta se cancela, las demÃ¡s completan
   - CancelaciÃ³n en cadena: si perfil falla con 401, las demÃ¡s se cancelan
   - Timeout global del dashboard respeta el lÃ­mite del usuario
   - CancelledError no deja sesiones abiertas (resource leak)
   - PeticiÃ³n cancelada no genera errores en el log

4. <em>Edge cases de concurrencia</em> (5 tests):
   - Todas las peticiones fallan simultÃ¡neamente
   - El servidor cierra la conexiÃ³n a mitad de respuesta
   - Respuesta llega despuÃ©s de que el timeout se activÃ³
   - Dos peticiones al mismo endpoint con parÃ¡metros diferentes
   - SesiÃ³n se cierra correctamente despuÃ©s de gather() con errores

<em>Para cada test incluye:</em>
- Nombre descriptivo
- Setup del mock con aioresponses
- Aserciones claras
- Comentario de quÃ© escenario especÃ­fico prueba

<em>Formato:</em> CÃ³digo Python completo con pytest-asyncio, listo para ejecutar.</p>
                </div>
                <div class="reto-ia-instrucciones">
                    <h4><span>ğŸ“</span> Instrucciones</h4>
                    <ol>
                        <li>Instala dependencias: <span class="codigo-inline">pip install pytest pytest-asyncio aioresponses</span></li>
                        <li>Crea el archivo <span class="codigo-inline">test_cliente_async.py</span> con los tests generados</li>
                        <li>Ejecuta: <span class="codigo-inline">pytest test_cliente_async.py -v</span></li>
                        <li>Para cada test que falle, corrige tu cliente asÃ­ncrono (no el test)</li>
                        <li>Agrega al menos 2 tests propios que prueben un escenario que la IA no cubriÃ³</li>
                    </ol>
                </div>
                <div class="reto-ia-entregable">
                    <h4><span>ğŸ“¦</span> Entregable</h4>
                    <p>Archivo <span class="codigo-inline">test_cliente_async.py</span> con 20+ tests pasando. Reporte de bugs encontrados durante testing y correcciones aplicadas.</p>
                </div>
            </div>

            <!-- RETO IA #9 - AVANZADO -->
            <div class="reto-ia reto-avanzado">
                <div class="reto-ia-header">
                    <div class="reto-ia-badge badge-avanzado">
                        <span class="reto-ia-numero">9</span>
                        <span>RETO IA</span>
                    </div>
                    <span class="reto-tipo-tag avanzado">ğŸš€ AVANZADO</span>
                </div>
                <h3 class="reto-ia-titulo">Benchmark SÃ­ncrono vs. AsÃ­ncrono</h3>
                <div class="reto-ia-rol">
                    <p class="reto-ia-rol-label">Rol asignado a la IA</p>
                    <p class="reto-ia-rol-text">ğŸ“Š Ingeniero de Rendimiento</p>
                </div>
                <div class="prompt-container">
                    <p class="prompt-label">
                        <span>ğŸ“‹</span>
                        <span>PROMPT COMPLETO</span>
                    </p>
                    <p class="prompt-text">ActÃºa como un ingeniero de rendimiento que diseÃ±a benchmarks rigurosos para clientes HTTP.

<em>Contexto:</em> Tengo dos versiones de mi cliente de EcoMarket: sÃ­ncrona (requests) y asÃ­ncrona (aiohttp). Necesito medir objetivamente cuÃ¡nto mejora la versiÃ³n asÃ­ncrona.

<em>Tu tarea:</em>
DiseÃ±a un script de benchmark que:

1. <em>Escenarios a medir:</em>
   - Dashboard: 4 peticiones GET simultÃ¡neas
   - CreaciÃ³n masiva: 20 productos POST
   - Mixto: 10 GET + 5 POST + 3 PATCH
   - Con latencia simulada: servidor con 200ms de delay por peticiÃ³n

2. <em>Para cada escenario, mide:</em>
   - Tiempo total de ejecuciÃ³n
   - Tiempo promedio por peticiÃ³n
   - Peticiones por segundo (throughput)
   - Memoria usada (con tracemalloc)
   - NÃºmero de conexiones TCP abiertas

3. <em>Condiciones de prueba:</em>
   - Ejecutar cada escenario 10 veces y promediar
   - Usar mock server con latencia configurable (0ms, 100ms, 500ms)
   - Medir con el servidor local (eliminar variabilidad de red)

4. <em>Genera:</em>
   - Tabla comparativa: sÃ­ncrono vs asÃ­ncrono para cada escenario y latencia
   - CÃ¡lculo de speedup (cuÃ¡ntas veces mÃ¡s rÃ¡pido)
   - Identificar el punto de cruce: Â¿con cuÃ¡ntas peticiones la asincronÃ­a empieza a ganar?
   - RecomendaciÃ³n: Â¿vale la pena la complejidad del cÃ³digo asÃ­ncrono para EcoMarket?

<em>Formato:</em> Script Python ejecutable que genera un reporte en consola con tablas formateadas.</p>
                </div>
                <div class="reto-ia-instrucciones">
                    <h4><span>ğŸ“</span> Instrucciones</h4>
                    <ol>
                        <li>Ejecuta el benchmark con tu mock server en las 3 latencias</li>
                        <li>Grafica los resultados (speedup vs. nÃºmero de peticiones)</li>
                        <li>Identifica el punto donde asÃ­ncrono supera a sÃ­ncrono</li>
                        <li>Documenta tus conclusiones: Â¿el esfuerzo de migraciÃ³n vale la pena?</li>
                    </ol>
                </div>
                <div class="reto-ia-entregable">
                    <h4><span>ğŸ“¦</span> Entregable</h4>
                    <p>Script <span class="codigo-inline">benchmark_sync_vs_async.py</span> + tabla de resultados + conclusiÃ³n de 1 pÃ¡rrafo sobre cuÃ¡ndo migrar a asÃ­ncrono.</p>
                </div>
            </div>

            <!-- CHECKPOINT METACOGNITIVO -->
            <div class="checkpoint-metacognitivo">
                <div class="checkpoint-header">
                    <div class="checkpoint-icon">ğŸª</div>
                    <h3 class="checkpoint-title">Checkpoint Metacognitivo - Fase Valida</h3>
                </div>
                <ul class="checkpoint-preguntas">
                    <li>Â¿EncontrÃ© bugs en mi cÃ³digo asÃ­ncrono que no existÃ­an en la versiÃ³n sÃ­ncrona?</li>
                    <li>Â¿Mis tests prueban el <em>timing</em> del cÃ³digo, no solo los datos?</li>
                    <li>Â¿Puedo detectar un resource leak (sesiÃ³n no cerrada) mirando un log?</li>
                    <li>Â¿El benchmark confirmÃ³ o desmintiÃ³ mi intuiciÃ³n sobre el speedup?</li>
                </ul>
            </div>

            <!-- INVARIANTES -->
            <div class="invariantes-box">
                <div class="invariantes-header">
                    <div class="invariantes-icon">ğŸ›¡ï¸</div>
                    <div>
                        <h3 class="invariantes-title">Invariantes que No Deben Romperse</h3>
                        <p class="invariantes-subtitle">Criterios de calidad para tests asÃ­ncronos</p>
                    </div>
                </div>
                <ul class="invariantes-lista">
                    <li>
                        <strong>Los tests asÃ­ncronos deben ser deterministas</strong>
                        Si un test pasa 9 de 10 veces, no es un test vÃ¡lido. Usa mocks para eliminar variabilidad de red.
                    </li>
                    <li>
                        <strong>Verificar cleanup despuÃ©s de errores, no solo despuÃ©s de Ã©xito</strong>
                        El test mÃ¡s importante es: Â¿se cierra la sesiÃ³n cuando gather() lanza una excepciÃ³n?
                    </li>
                    <li>
                        <strong>No mockear el event loop</strong>
                        Los tests deben usar el event loop real. Mockear asyncio.gather() no prueba tu cÃ³digo, prueba tu mock.
                    </li>
                    <li>
                        <strong>Benchmarks sin mocks, tests con mocks</strong>
                        Para medir rendimiento, usa un servidor real (mock server con delay). Para tests funcionales, usa mocks para determinismo.
                    </li>
                </ul>
                <div class="invariantes-nota">
                    <span>ğŸ’¡</span>
                    <span>Un cÃ³digo asÃ­ncrono sin tests de concurrencia es mÃ¡s peligroso que un cÃ³digo sÃ­ncrono sin tests: los bugs se manifiestan solo bajo condiciones especÃ­ficas de timing.</span>
                </div>
            </div>
        </section>

        <!-- ========== FASE 5: PROFUNDIZA ========== -->
        <section id="profundiza" class="fase-section">
            <div class="fase-header" data-fase="profundiza">
                <div class="fase-numero">5</div>
                <div class="fase-info">
                    <h2 class="fase-nombre">PROFUNDIZA</h2>
                    <p class="fase-bloom">Nivel Bloom: <strong>Crear</strong></p>
                </div>
                <div class="fase-tiempo">
                    <span>â±ï¸</span>
                    <span>45 minutos</span>
                </div>
            </div>

            <div class="objetivos-box">
                <h3 class="objetivos-titulo">
                    <span>ğŸ¯</span>
                    Objetivos de Aprendizaje
                </h3>
                <ul class="objetivos-lista">
                    <li>Explorar patrones avanzados de concurrencia aplicados a clientes HTTP</li>
                    <li>Conectar la asincronÃ­a con temas futuros: polling, WebSocket, offline-first</li>
                    <li>Identificar problemas abiertos que se resolverÃ¡n en semanas posteriores</li>
                    <li>Crear extensiones originales al cliente asÃ­ncrono</li>
                </ul>
            </div>

            <div class="contenido-section">
                <h3>Hacia la Semana 4: Polling y SuscripciÃ³n a Eventos</h3>
                <p>
                    Tu cliente asÃ­ncrono ya puede lanzar mÃºltiples peticiones y coordinar resultados.
                    Pero hay un problema que aÃºn no resuelves: Â¿cÃ³mo sabe el cliente que los datos 
                    cambiaron en el servidor?
                </p>

                <div class="diagrama-container">
                    <div class="diagrama-ascii">
<span class="diagrama-titulo">â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              ROADMAP: DE SEMANA 3 AL PROYECTO FINAL             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</span>

SEMANA 3 (AHORA)               PRÃ“XIMAS SEMANAS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•               â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Cliente AsÃ­ncronoâ”‚            â”‚ SEMANA 4         â”‚
â”‚ â€¢ gather/wait   â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚ Polling y        â”‚
â”‚ â€¢ Timeouts      â”‚            â”‚ Eventos          â”‚
â”‚ â€¢ CancelaciÃ³n   â”‚            â”‚ â€¢ Short polling  â”‚
â”‚ â€¢ SemÃ¡foro      â”‚            â”‚ â€¢ Long polling   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚ â€¢ PatrÃ³n Observerâ”‚
        â”‚                      â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚                               â”‚
        â”‚                      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚                      â”‚ SEMANAS 6-7       â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚ Arquitectura      â”‚
                               â”‚ â€¢ async Repositoryâ”‚
                               â”‚ â€¢ CachÃ© + async   â”‚
                               â”‚ â€¢ Estado reactivo â”‚
                               â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                        â”‚
                               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                               â”‚ SEMANA 9          â”‚
                               â”‚ Resiliencia       â”‚
                               â”‚ â€¢ Retry + async   â”‚
                               â”‚ â€¢ Circuit breaker â”‚
                               â”‚ â€¢ Fallbacks       â”‚
                               â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                        â”‚
                               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                               â”‚ SEMANA 11         â”‚
                               â”‚ WebSocket         â”‚
                               â”‚ â€¢ ConexiÃ³n persistâ”‚
                               â”‚ â€¢ Bidireccional   â”‚
                               â”‚ â€¢ Event loop como â”‚
                               â”‚   listener        â”‚
                               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    </div>
                    <div class="diagrama-descripcion">
                        <strong>ConexiÃ³n con el futuro:</strong> La asincronÃ­a de esta semana es la base de todo 
                        lo que viene. El polling (Semana 4) necesita ejecutar peticiones periÃ³dicas sin bloquear. 
                        Los WebSocket (Semana 11) son inherentemente asÃ­ncronos. El circuit breaker (Semana 9) 
                        necesita coordinar el estado de mÃºltiples peticiones concurrentes.
                    </div>
                </div>
            </div>

            <div class="contenido-section">
                <h3>Preguntas Abiertas para Explorar</h3>
                <p>
                    Ahora que manejas concurrencia, surgen preguntas mÃ¡s profundas:
                </p>
                <ul class="lista-conceptos">
                    <li>Â¿CÃ³mo hago polling eficiente sin saturar el servidor? (â†’ Semana 4: short polling, long polling)</li>
                    <li>Si dos peticiones concurrentes modifican el mismo recurso, Â¿quiÃ©n gana? (â†’ Semana 7: resoluciÃ³n de conflictos)</li>
                    <li>Â¿CÃ³mo combino el retry de la Semana 2 con la concurrencia de la Semana 3? (â†’ Semana 9: resiliencia avanzada)</li>
                    <li>Â¿Puedo mantener una conexiÃ³n abierta permanente en lugar de abrir/cerrar por peticiÃ³n? (â†’ Semana 11: WebSocket)</li>
                    <li>Â¿CÃ³mo pruebo que mi cÃ³digo asÃ­ncrono no tiene race conditions sutiles? (â†’ Semana 13: testing avanzado)</li>
                </ul>
            </div>

            <!-- RETO IA #10 - AVANZADO (EXTENSIÃ“N) -->
            <div class="reto-ia reto-avanzado">
                <div class="reto-ia-header">
                    <div class="reto-ia-badge badge-avanzado">
                        <span class="reto-ia-numero">10</span>
                        <span>RETO IA Â· EXTENSIÃ“N</span>
                    </div>
                    <span class="reto-tipo-tag avanzado">ğŸš€ AVANZADO</span>
                </div>
                <h3 class="reto-ia-titulo">DiseÃ±ador de Pool de Conexiones Inteligente</h3>
                <div class="reto-ia-rol">
                    <p class="reto-ia-rol-label">Rol asignado a la IA</p>
                    <p class="reto-ia-rol-text">ğŸŠ Arquitecto de Conexiones</p>
                </div>
                <div class="prompt-container">
                    <p class="prompt-label">
                        <span>ğŸ“‹</span>
                        <span>PROMPT COMPLETO</span>
                    </p>
                    <p class="prompt-text">ActÃºa como un arquitecto de infraestructura de conexiones. Necesito entender y configurar correctamente el pool de conexiones de mi cliente HTTP.

<em>Contexto:</em> Mi cliente de EcoMarket usa una sola ClientSession de aiohttp. SÃ© que internamente maneja un pool de conexiones TCP, pero no entiendo cÃ³mo configurarlo ni cÃ³mo afecta al rendimiento.

<em>Tu tarea:</em>
1. Explica cÃ³mo funciona el <em>connection pool</em> de aiohttp:
   - Â¿CuÃ¡ntas conexiones TCP mantiene abiertas?
   - Â¿QuÃ© pasa cuando se excede el lÃ­mite?
   - Â¿CÃ³mo se reutilizan las conexiones (keep-alive)?
   - Â¿QuÃ© es el TCPConnector y cÃ³mo se configura?

2. Implementa un <em>SmartSession</em> que:
   - Configure el TCPConnector con lÃ­mites apropiados para EcoMarket
   - Monitoree el estado del pool (conexiones activas, en espera, disponibles)
   - Registre mÃ©tricas: conexiones creadas, reutilizadas, cerradas
   - Implemente un health check periÃ³dico del pool

3. Demuestra el impacto de la configuraciÃ³n con benchmark:
   - Compara pool de 5 conexiones vs. 20 conexiones vs. ilimitado
   - Escenario: 50 peticiones concurrentes con server de 100ms delay
   - Mide: throughput, latencia, conexiones TCP en uso

4. Genera un diagrama mostrando:
   - CÃ³mo 10 peticiones comparten 5 conexiones del pool
   - QuÃ© pasa cuando la conexiÃ³n 6 llega (cola de espera)
   - CÃ³mo keep-alive evita el overhead de TCP handshake

<em>Requisito:</em> El SmartSession debe ser drop-in replacement para ClientSession en mi cÃ³digo existente.</p>
                </div>
                <div class="reto-ia-instrucciones">
                    <h4><span>ğŸ“</span> Instrucciones</h4>
                    <ol>
                        <li>Implementa SmartSession y Ãºsala en cargar_dashboard()</li>
                        <li>Ejecuta el benchmark con las 3 configuraciones de pool</li>
                        <li>Observa en las mÃ©tricas cuÃ¡ntas conexiones se reutilizan</li>
                        <li>Documenta la configuraciÃ³n Ã³ptima para EcoMarket y por quÃ©</li>
                    </ol>
                </div>
                <div class="reto-ia-entregable">
                    <h4><span>ğŸ“¦</span> Entregable</h4>
                    <p>MÃ³dulo <span class="codigo-inline">smart_session.py</span> con la implementaciÃ³n y benchmark. Documento explicando la configuraciÃ³n Ã³ptima del pool y las mÃ©tricas observadas.</p>
                </div>
            </div>

            <!-- CHECKPOINT METACOGNITIVO -->
            <div class="checkpoint-metacognitivo">
                <div class="checkpoint-header">
                    <div class="checkpoint-icon">ğŸª</div>
                    <h3 class="checkpoint-title">Checkpoint Metacognitivo - Fase Profundiza</h3>
                </div>
                <ul class="checkpoint-preguntas">
                    <li>Â¿QuÃ© pregunta tÃ©cnica tengo ahora que no tenÃ­a al comenzar la semana?</li>
                    <li>Â¿Puedo ver cÃ³mo la concurrencia de esta semana conecta con el polling de la Semana 4?</li>
                    <li>Â¿Propuse alguna extensiÃ³n que la IA no habÃ­a sugerido?</li>
                    <li>Si tuviera que explicar "event loop" a alguien que no programa, Â¿quÃ© analogÃ­a usarÃ­a?</li>
                </ul>
            </div>

            <!-- INVARIANTES -->
            <div class="invariantes-box">
                <div class="invariantes-header">
                    <div class="invariantes-icon">ğŸ›¡ï¸</div>
                    <div>
                        <h3 class="invariantes-title">Invariantes que No Deben Romperse</h3>
                        <p class="invariantes-subtitle">Principios para extensiones de concurrencia</p>
                    </div>
                </div>
                <ul class="invariantes-lista">
                    <li>
                        <strong>MÃ¡s conexiones no siempre significa mÃ¡s rendimiento</strong>
                        Un pool demasiado grande puede saturar el servidor o agotar recursos del sistema operativo. Mide antes de aumentar.
                    </li>
                    <li>
                        <strong>Las extensiones no deben cambiar la interfaz de las funciones CRUD</strong>
                        El SmartSession debe ser transparente: el cÃ³digo que lo usa no debe saber que existe.
                    </li>
                    <li>
                        <strong>Siempre cerrar el pool al terminar la aplicaciÃ³n</strong>
                        Conexiones TCP no cerradas quedan en estado TIME_WAIT y consumen recursos del SO por minutos.
                    </li>
                </ul>
                <div class="invariantes-nota">
                    <span>ğŸ’¡</span>
                    <span>La configuraciÃ³n del pool de conexiones es una de las primeras cosas que se ajusta en producciÃ³n. Aprende a medirla ahora para no adivinar despuÃ©s.</span>
                </div>
            </div>
        </section>

        <!-- ========== SISTEMA DE EVALUACIÃ“N ========== -->
        <section id="evaluacion" class="evaluacion-section">
            <div class="section-header">
                <div class="section-icon">ğŸ“Š</div>
                <h2 class="section-title">Sistema de EvaluaciÃ³n - Semana 3</h2>
            </div>
            <p style="color: var(--text-secondary); margin-bottom: 1.5rem;">
                La evaluaciÃ³n mide tanto la correcta implementaciÃ³n de la concurrencia como la comprensiÃ³n 
                de cuÃ¡ndo y por quÃ© usarla. Los retos avanzados bonifican pero no son obligatorios.
            </p>
            <div class="evaluacion-grid">
                <div class="evaluacion-item">
                    <div class="evaluacion-item-info">
                        <div class="evaluacion-item-fase" style="background: var(--fase-comprende);">1</div>
                        <span class="evaluacion-item-nombre">Retos 1-2: Modelos de concurrencia + Event loop</span>
                    </div>
                    <span class="evaluacion-item-porcentaje">15%</span>
                </div>
                <div class="evaluacion-item">
                    <div class="evaluacion-item-info">
                        <div class="evaluacion-item-fase" style="background: var(--fase-aplica);">2</div>
                        <span class="evaluacion-item-nombre">Retos 3-4: Cliente async + Timeouts y cancelaciÃ³n</span>
                    </div>
                    <span class="evaluacion-item-porcentaje">35%</span>
                </div>
                <div class="evaluacion-item">
                    <div class="evaluacion-item-info">
                        <div class="evaluacion-item-fase" style="background: var(--fase-reflexiona);">3</div>
                        <span class="evaluacion-item-nombre">Reto 6: ADR de decisiones de concurrencia</span>
                    </div>
                    <span class="evaluacion-item-porcentaje">15%</span>
                </div>
                <div class="evaluacion-item">
                    <div class="evaluacion-item-info">
                        <div class="evaluacion-item-fase" style="background: var(--fase-valida);">4</div>
                        <span class="evaluacion-item-nombre">Reto 8: Suite de pruebas asÃ­ncronas (20+ tests)</span>
                    </div>
                    <span class="evaluacion-item-porcentaje">25%</span>
                </div>
                <div class="evaluacion-item">
                    <div class="evaluacion-item-info">
                        <div class="evaluacion-item-fase" style="background: var(--fase-profundiza);">5</div>
                        <span class="evaluacion-item-nombre">Checkpoints metacognitivos completados</span>
                    </div>
                    <span class="evaluacion-item-porcentaje">10%</span>
                </div>
            </div>

            <div class="caja-contextual caja-success" style="margin-top: 2rem;">
                <span class="caja-contextual-icon">ğŸŒŸ</span>
                <div class="caja-contextual-content">
                    <h4>BonificaciÃ³n por Retos Avanzados</h4>
                    <p>Los retos 5, 7, 9 y 10 (marcados como ğŸš€ AVANZADO) otorgan hasta <strong>+15% extra</strong> sobre la calificaciÃ³n base. No son obligatorios pero demuestran dominio profundo del tema.</p>
                </div>
            </div>
        </section>

        <!-- ========== GLOSARIO ========== -->
        <section id="glosario" class="glosario-section">
            <div class="section-header">
                <div class="section-icon">ğŸ“–</div>
                <h2 class="section-title">Glosario - Semana 3</h2>
            </div>
            <div class="glosario-grid">
                <div class="glosario-item">
                    <p class="glosario-termino">
                        Concurrencia
                        <span class="glosario-tipo disciplinar">Disciplinar</span>
                    </p>
                    <p class="glosario-definicion">Capacidad de un programa de gestionar mÃºltiples tareas intercaladas en un solo hilo. Las tareas progresan alternÃ¡ndose, no simultÃ¡neamente. Ideal para I/O-bound (esperas de red).</p>
                </div>
                <div class="glosario-item">
                    <p class="glosario-termino">
                        Paralelismo
                        <span class="glosario-tipo disciplinar">Disciplinar</span>
                    </p>
                    <p class="glosario-definicion">EjecuciÃ³n simultÃ¡nea real de tareas en mÃºltiples nÃºcleos de CPU. Ideal para CPU-bound (cÃ¡lculos pesados). Diferente de concurrencia.</p>
                </div>
                <div class="glosario-item">
                    <p class="glosario-termino">
                        Event Loop
                        <span class="glosario-tipo disciplinar">Disciplinar</span>
                    </p>
                    <p class="glosario-definicion">Mecanismo central que coordina la ejecuciÃ³n de tareas asÃ­ncronas. Verifica continuamente si hay tareas listas para ejecutar o eventos de I/O que atender.</p>
                </div>
                <div class="glosario-item">
                    <p class="glosario-termino">
                        Coroutine
                        <span class="glosario-tipo disciplinar">Disciplinar</span>
                    </p>
                    <p class="glosario-definicion">FunciÃ³n definida con <code>async def</code> que puede pausar su ejecuciÃ³n en puntos <code>await</code> y reanudarla despuÃ©s, permitiendo que otras coroutines ejecuten.</p>
                </div>
                <div class="glosario-item">
                    <p class="glosario-termino">
                        asyncio.gather()
                        <span class="glosario-tipo disciplinar">Disciplinar</span>
                    </p>
                    <p class="glosario-definicion">FunciÃ³n de asyncio que ejecuta mÃºltiples coroutines concurrentemente y retorna todos los resultados cuando todas terminan. Con <code>return_exceptions=True</code>, los errores se retornan como valores en vez de propagarse.</p>
                </div>
                <div class="glosario-item">
                    <p class="glosario-termino">
                        SemÃ¡foro (Semaphore)
                        <span class="glosario-tipo disciplinar">Disciplinar</span>
                    </p>
                    <p class="glosario-definicion">Mecanismo de sincronizaciÃ³n que limita el nÃºmero de tareas que pueden acceder simultÃ¡neamente a un recurso. En clientes HTTP, limita las peticiones concurrentes.</p>
                </div>
                <div class="glosario-item">
                    <p class="glosario-termino">
                        Token Bucket
                        <span class="glosario-tipo disciplinar">Disciplinar</span>
                    </p>
                    <p class="glosario-definicion">Algoritmo de rate limiting que genera "tokens" a tasa constante. Cada peticiÃ³n consume un token. Si no hay tokens, la peticiÃ³n espera. Permite rÃ¡fagas cortas.</p>
                </div>
                <div class="glosario-item">
                    <p class="glosario-termino">
                        Resource Leak
                        <span class="glosario-tipo disciplinar">Disciplinar</span>
                    </p>
                    <p class="glosario-definicion">Error donde un recurso del sistema (conexiÃ³n, archivo, memoria) no se libera correctamente. En cÃ³digo asÃ­ncrono, ocurre cuando una sesiÃ³n HTTP no se cierra despuÃ©s de un error.</p>
                </div>
                <div class="glosario-item">
                    <p class="glosario-termino">
                        Connection Pool
                        <span class="glosario-tipo disciplinar">Disciplinar</span>
                    </p>
                    <p class="glosario-definicion">Conjunto de conexiones TCP pre-establecidas y reutilizables. Evita el overhead de crear una nueva conexiÃ³n TCP (three-way handshake) por cada peticiÃ³n HTTP.</p>
                </div>
                <div class="glosario-item">
                    <p class="glosario-termino">
                        CancelledError
                        <span class="glosario-tipo disciplinar">Disciplinar</span>
                    </p>
                    <p class="glosario-definicion">ExcepciÃ³n de asyncio que se lanza cuando una tarea es cancelada externamente. Debe manejarse para liberar recursos (cleanup), nunca suprimirse silenciosamente.</p>
                </div>
                <div class="glosario-item">
                    <p class="glosario-termino">
                        Race Condition
                        <span class="glosario-tipo disciplinar">Disciplinar</span>
                    </p>
                    <p class="glosario-definicion">Bug que ocurre cuando el comportamiento del programa depende del orden temporal de eventos no controlados. En clientes async, puede ocurrir cuando dos tareas modifican el mismo estado.</p>
                </div>
                <div class="glosario-item">
                    <p class="glosario-termino">
                        Agencia Compartida
                        <span class="glosario-tipo aetl">AETL</span>
                    </p>
                    <p class="glosario-definicion">Balance entre la autonomÃ­a del estudiante y la asistencia de la IA. El estudiante mantiene el rol de Arquitecto: usa la IA como herramienta, no como sustituto de su pensamiento.</p>
                </div>
            </div>
        </section>

        <!-- ========== REFERENCIAS ========== -->
        <section class="referencias-section">
            <div class="section-header">
                <div class="section-icon">ğŸ“š</div>
                <h2 class="section-title">Referencias</h2>
            </div>
            <div class="referencias-lista">
                <div class="referencia-item">
                    <strong>Python Software Foundation. (2024).</strong> asyncio â€” Asynchronous I/O. <em>Python 3.12 Documentation.</em> Referencia oficial del mÃ³dulo asyncio, incluyendo event loop, gather, wait, y semÃ¡foros.
                </div>
                <div class="referencia-item">
                    <strong>aiohttp Contributors. (2024).</strong> aiohttp: Async HTTP Client/Server for asyncio and Python. <em>DocumentaciÃ³n oficial.</em> Referencia para ClientSession, TCPConnector, y configuraciÃ³n de timeouts.
                </div>
                <div class="referencia-item">
                    <strong>Hattingh, C. (2020).</strong> <em>Using Asyncio in Python: Understanding Python's Asynchronous Programming Features.</em> O'Reilly Media. CapÃ­tulos 2-4: fundamentos de asyncio, patrones de uso, y mejores prÃ¡cticas.
                </div>
                <div class="referencia-item">
                    <strong>Nygard, M. (2018).</strong> <em>Release It! Design and Deploy Production-Ready Software</em> (2nd ed.). Pragmatic Bookshelf. CapÃ­tulo 4: Timeouts. CapÃ­tulo 5: Circuit Breaker y Bulkhead (semÃ¡foro).
                </div>
                <div class="referencia-item">
                    <strong>Kleppmann, M. (2017).</strong> <em>Designing Data-Intensive Applications.</em> O'Reilly Media. CapÃ­tulo 8: The Trouble with Distributed Systems (timeouts, concurrencia, race conditions).
                </div>
                <div class="referencia-item">
                    <strong>Fowler, M. (2002).</strong> <em>Patterns of Enterprise Application Architecture.</em> Addison-Wesley. Connection Pool pattern y Unit of Work para gestiÃ³n de sesiones.
                </div>
            </div>
        </section>

    </main>

    <!-- ========== FOOTER ========== -->
    <footer class="footer">
        <div class="footer-content">
            <p class="footer-logo">Universidad AutÃ³noma de Nayarit</p>
            <div class="footer-modelo">
                <span>ğŸ§ </span>
                <span>Modelo AETL v1.0</span>
            </div>
            <p class="footer-text">
                ProgramaciÃ³n Distribuida del Lado del Cliente<br>
                Licenciatura en Sistemas Computacionales<br>
                Documento de trabajo Â· Semana 3 de 15
            </p>
			<p>Dr. Eligardo Cruz SÃ¡nchez</p>
        </div>
    </footer>

    <script>
        // Intersection Observer para actualizar progreso y navegaciÃ³n
        document.addEventListener('DOMContentLoaded', function() {
            const sections = document.querySelectorAll('.fase-section');
            const progressSegments = document.querySelectorAll('.progress-segment');
            const progressStats = document.querySelector('.progress-stats');
            const navLinks = document.querySelectorAll('.nav-fase');
            
            const faseNames = {
                'comprende': 'Comprende',
                'aplica': 'Aplica',
                'reflexiona': 'Reflexiona',
                'valida': 'Valida',
                'profundiza': 'Profundiza'
            };

            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const fase = entry.target.id;
                        updateProgress(fase);
                        updateNav(fase);
                    }
                });
            }, {
                rootMargin: '-20% 0px -70% 0px'
            });

            sections.forEach(section => observer.observe(section));

            function updateProgress(currentFase) {
                const fases = ['comprende', 'aplica', 'reflexiona', 'valida', 'profundiza'];
                const currentIndex = fases.indexOf(currentFase);
                
                progressSegments.forEach((segment, index) => {
                    const fase = segment.dataset.fase;
                    const faseIndex = fases.indexOf(fase);
                    
                    if (faseIndex <= currentIndex) {
                        segment.style.width = '20%';
                    } else {
                        segment.style.width = '0%';
                    }
                });

                if (progressStats && faseNames[currentFase]) {
                    progressStats.textContent = `Fase actual: ${faseNames[currentFase]}`;
                }
            }

            function updateNav(currentFase) {
                navLinks.forEach(link => {
                    link.style.background = '';
                    link.style.color = '';
                    
                    if (link.getAttribute('href') === `#${currentFase}`) {
                        const faseColor = getComputedStyle(document.documentElement)
                            .getPropertyValue(`--fase-${currentFase}`);
                        link.style.background = `${faseColor}15`;
                        link.style.color = faseColor;
                    }
                });
            }

            // Smooth scroll para navegaciÃ³n
            navLinks.forEach(link => {
                link.addEventListener('click', function(e) {
                    const href = this.getAttribute('href');
                    if (href.startsWith('#')) {
                        e.preventDefault();
                        const target = document.querySelector(href);
                        if (target) {
                            target.scrollIntoView({ behavior: 'smooth' });
                        }
                    }
                });
            });
        });
    </script>
</body>
</html>
